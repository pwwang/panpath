{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"/]+|(?!\\b)(?=[A-Z][a-z])|\\.(?!\\d)|&[lg]t;","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"PanPath","text":"\ud83c\udf0d Universal sync/async local/cloud path library <p>A pathlib-compatible interface for Python that works seamlessly across local and cloud storage</p> <p> </p>"},{"location":"#features","title":"\u2728 Features","text":"<ul> <li> <p> Unified Interface</p> <p>Single API for local and cloud storage (S3, Google Cloud Storage, Azure Blob Storage)</p> </li> <li> <p> Sync &amp; Async</p> <p>Choose synchronous or asynchronous operations based on your needs</p> </li> <li> <p> Pathlib Compatible</p> <p>Drop-in replacement for <code>pathlib.Path</code> for local files</p> </li> <li> <p> Lazy Loading</p> <p>Cloud clients instantiated only when needed for better performance</p> </li> <li> <p> Cross-Storage Operations</p> <p>Copy/move files between different storage backends seamlessly</p> </li> <li> <p> Bulk Operations</p> <p>Efficient <code>rmtree</code>, <code>copy</code>, <code>copytree</code> for directories</p> </li> <li> <p> Testable</p> <p>Local mock infrastructure for testing without cloud resources</p> </li> <li> <p> Optional Dependencies</p> <p>Install only what you need - minimal core with optional cloud backends</p> </li> </ul>"},{"location":"#quick-example","title":"\ud83d\ude80 Quick Example","text":"SyncAsyncCross-Storage <pre><code>from panpath import PanPath\n\n# Local files (pathlib.Path compatible)\nlocal = PanPath(\"/path/to/file.txt\")\ncontent = local.read_text()\n\n# S3 (synchronous)\ns3_file = PanPath(\"s3://bucket/key/file.txt\")\ncontent = s3_file.read_text()\n\n# Google Cloud Storage\ngs_file = PanPath(\"gs://bucket/path/file.txt\")\ncontent = gs_file.read_text()\n\n# Azure Blob Storage\nazure_file = PanPath(\"az://container/path/file.txt\")\ncontent = azure_file.read_text()\n</code></pre> <pre><code>from panpath import AsyncPanPath\n\n# Async S3\nasync_s3 = AsyncPanPath(\"s3://bucket/key/file.txt\")\ncontent = await async_s3.read_text()\n\n# Async GCS\nasync_gs = AsyncPanPath(\"gs://bucket/path/file.txt\")\ncontent = await async_gs.read_text()\n\n# Async local files\nasync_local = AsyncPanPath(\"/path/to/file.txt\")\nasync with async_local.open(\"r\") as f:\n    content = await f.read()\n</code></pre> <pre><code>from panpath import PanPath\n\n# Copy from S3 to GCS\ns3_file = PanPath(\"s3://my-bucket/data.csv\")\ns3_file.copy(\"gs://other-bucket/data.csv\")\n\n# Copy entire directory from cloud to local\ncloud_dir = PanPath(\"s3://data-lake/dataset/\")\ncloud_dir.copytree(\"/tmp/dataset/\")\n\n# Move between cloud providers\nazure_file = PanPath(\"az://container/file.txt\")\nazure_file.rename(\"s3://bucket/file.txt\")\n</code></pre>"},{"location":"#installation","title":"\ud83d\udce6 Installation","text":"<p>Install the core library:</p> <pre><code>pip install panpath\n</code></pre> <p>With cloud storage support:</p> S3Google Cloud StorageAzure Blob StorageAll Backends <pre><code>pip install panpath[s3]        # Sync\npip install panpath[async-s3]  # Async\n</code></pre> <pre><code>pip install panpath[gs]        # Sync\npip install panpath[async-gs]  # Async\n</code></pre> <pre><code>pip install panpath[azure]        # Sync\npip install panpath[async-azure]  # Async\n</code></pre> <pre><code>pip install panpath[all-sync]   # All sync backends\npip install panpath[all-async]  # All async backends\npip install panpath[all]        # Everything\n</code></pre>"},{"location":"#use-cases","title":"\ud83c\udfaf Use Cases","text":"<p>Local Development \u2192 Cloud Production: Write code using local paths during development, switch to cloud paths in production with minimal changes.</p> <p>Multi-Cloud Applications: Build applications that work with multiple cloud providers without vendor lock-in.</p> <p>Data Pipelines: Create ETL pipelines that seamlessly move data between local storage and cloud services.</p> <p>Async I/O: Leverage async/await for high-performance cloud operations in async frameworks like FastAPI, aiohttp, or asyncio scripts.</p> <p>Testing: Use local paths in tests, cloud paths in production - same code, different backends.</p>"},{"location":"#documentation-structure","title":"\ud83d\udcda Documentation Structure","text":"<ul> <li> <p> Getting Started</p> <p>Installation, quick start, and basic concepts</p> </li> <li> <p> User Guide</p> <p>Comprehensive guides for all features</p> </li> <li> <p> Cloud Providers</p> <p>Provider-specific documentation and examples</p> </li> <li> <p> API Reference</p> <p>Complete API documentation with examples</p> </li> </ul>"},{"location":"#contributing","title":"\ud83e\udd1d Contributing","text":"<p>Contributions are welcome! Please see our Contributing Guide for details.</p>"},{"location":"#license","title":"\ud83d\udcc4 License","text":"<p>This project is licensed under the MIT License - see the LICENSE file for details.</p>"},{"location":"#acknowledgments","title":"\ud83d\ude4f Acknowledgments","text":"<p>PanPath is inspired by:</p> <ul> <li>pathlib - Python's standard library for filesystem paths</li> <li>cloudpathlib - Path-like interface for cloud storage</li> </ul> <p>Made with \u2764\ufe0f by the PanPath contributors</p> <p> GitHub \u2022     PyPI \u2022     Issues </p>"},{"location":"about/changelog/","title":"Changelog","text":"<p>All notable changes to PanPath will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"about/changelog/#010-2025-12-17","title":"[0.1.0] - 2025-12-17","text":""},{"location":"about/changelog/#added","title":"Added","text":"<ul> <li>Core Features</li> <li>Unified <code>PanPath</code> interface for local and cloud storage</li> <li>Support for Amazon S3, Google Cloud Storage, and Azure Blob Storage</li> <li>Synchronous and asynchronous operation modes</li> <li>Pathlib-compatible interface for local files</li> <li> <p>Lazy client loading for better performance</p> </li> <li> <p>Path Operations</p> </li> <li>All standard pathlib operations (<code>read_text</code>, <code>write_text</code>, <code>exists</code>, etc.)</li> <li>Path manipulation (<code>parent</code>, <code>name</code>, <code>stem</code>, <code>suffix</code>, <code>with_*</code>)</li> <li>Pattern matching (<code>glob</code>, <code>rglob</code>, <code>match</code>)</li> <li> <p>Directory traversal (<code>iterdir</code>, <code>walk</code>)</p> </li> <li> <p>Bulk Operations</p> </li> <li><code>rmtree()</code> - Remove directory and all contents</li> <li><code>copy()</code> - Copy files with cross-storage support</li> <li><code>copytree()</code> - Copy entire directory trees</li> <li> <p><code>rename()</code> - Enhanced rename with cross-storage support</p> </li> <li> <p>Cloud Features</p> </li> <li>Server-side copy optimization (same-backend transfers)</li> <li>Cross-storage transfers (copy between different cloud providers)</li> <li>Automatic multipart upload for large files</li> <li> <p>Cloud-specific properties (<code>cloud_prefix</code>, <code>key</code>, <code>bucket</code>)</p> </li> <li> <p>Async Support</p> </li> <li>Full async/await support for all operations</li> <li><code>AsyncPanPath</code> for always-async usage</li> <li>Async context managers for file operations</li> <li> <p>Parallel async operations with <code>asyncio.gather</code></p> </li> <li> <p>Developer Experience</p> </li> <li>Type hints throughout</li> <li>Optional dependencies (install only what you need)</li> <li>Comprehensive test suite with 114+ passing tests</li> <li> <p>Cloudpathlib compatibility layer</p> </li> <li> <p>Documentation</p> </li> <li>Complete Material for MkDocs documentation</li> <li>Getting started guides</li> <li>User guide with examples</li> <li>Provider-specific documentation</li> <li>API reference</li> <li>Migration guides from pathlib and cloudpathlib</li> </ul>"},{"location":"about/changelog/#changed","title":"Changed","text":"<ul> <li>N/A (initial release)</li> </ul>"},{"location":"about/changelog/#deprecated","title":"Deprecated","text":"<ul> <li>N/A (initial release)</li> </ul>"},{"location":"about/changelog/#removed","title":"Removed","text":"<ul> <li>N/A (initial release)</li> </ul>"},{"location":"about/changelog/#fixed","title":"Fixed","text":"<ul> <li>N/A (initial release)</li> </ul>"},{"location":"about/changelog/#security","title":"Security","text":"<ul> <li>N/A (initial release)</li> </ul>"},{"location":"about/changelog/#unreleased","title":"[Unreleased]","text":""},{"location":"about/changelog/#planned-features","title":"Planned Features","text":"<ul> <li>File caching support</li> <li>Progress callbacks for bulk operations</li> <li>Streaming uploads and downloads</li> <li>Additional cloud provider support</li> <li>Performance optimizations</li> <li>Enhanced error messages</li> </ul>"},{"location":"about/changelog/#release-notes","title":"Release Notes","text":""},{"location":"about/changelog/#version-010-initial-release","title":"Version 0.1.0 - Initial Release","text":"<p>This is the initial release of PanPath, providing a unified interface for working with local and cloud storage.</p> <p>Highlights:</p> <p>\u2728 Unified API - Same interface for local files, S3, GCS, and Azure \u26a1 Async Support - Full async/await for high-performance I/O \ud83d\udd04 Cross-Storage - Copy files between different cloud providers \ud83d\udce6 Optional Dependencies - Install only what you need \ud83c\udfaf Pathlib Compatible - Drop-in replacement for pathlib.Path</p> <p>Supported Operations:</p> <ul> <li>Reading and writing files (text and binary)</li> <li>Path manipulation and querying</li> <li>Directory operations (list, walk, glob)</li> <li>Bulk operations (copy, move, delete trees)</li> <li>Cross-storage transfers</li> <li>Async and sync modes</li> </ul> <p>Supported Backends:</p> <ul> <li>Local filesystem</li> <li>Amazon S3 (sync and async)</li> <li>Google Cloud Storage (sync and async)</li> <li>Azure Blob Storage (sync and async)</li> </ul> <p>Installation:</p> <pre><code>pip install panpath[all]\n</code></pre> <p>Quick Example:</p> <pre><code>from panpath import PanPath\n\n# Works the same for local and cloud\nlocal = PanPath(\"/tmp/file.txt\")\ns3 = PanPath(\"s3://bucket/file.txt\")\ngs = PanPath(\"gs://bucket/file.txt\")\n\n# Same operations\nfor path in [local, s3, gs]:\n    path.write_text(\"Hello, PanPath!\")\n    print(path.read_text())\n</code></pre>"},{"location":"about/changelog/#contributing","title":"Contributing","text":"<p>See CONTRIBUTING.md for information on how to contribute to PanPath.</p>"},{"location":"about/changelog/#links","title":"Links","text":"<ul> <li>PyPI</li> <li>GitHub Repository</li> <li>Documentation</li> <li>Issue Tracker</li> </ul>"},{"location":"about/cloudpathlib-compat/","title":"Cloudpathlib Compatibility","text":"<p>This document describes PanPath's compatibility with cloudpathlib and the tests adapted from their comprehensive test suite.</p>"},{"location":"about/cloudpathlib-compat/#overview","title":"Overview","text":"<p>PanPath provides a cloudpathlib-compatible interface for path operations across S3, GCS, and Azure Blob Storage. While the internal architecture differs (metaclass-based routing vs class hierarchy, explicit sync/async separation), the public API is designed to be compatible with cloudpathlib's interface.</p>"},{"location":"about/cloudpathlib-compat/#test-coverage","title":"Test Coverage","text":"<p>We've adapted key tests from cloudpathlib's test suite to verify compatibility:</p>"},{"location":"about/cloudpathlib-compat/#path-manipulation-testpathmanipulation","title":"\u2705 Path Manipulation (<code>TestPathManipulation</code>)","text":"<ul> <li>Properties: <code>name</code>, <code>stem</code>, <code>suffix</code>, <code>suffixes</code>, <code>parts</code></li> <li>Path operations: <code>with_suffix()</code>, <code>with_stem()</code>, <code>with_name()</code></li> <li>Joins: <code>/</code> operator, <code>joinpath()</code>, <code>parent</code>, <code>parents</code></li> <li>Cloud-specific: <code>cloud_prefix</code>, <code>key</code> properties</li> <li>Comparison: Equality, hashing, sorting</li> <li>Pattern matching: <code>match()</code> with glob patterns (including <code>**</code> recursive)</li> <li>URI operations: <code>as_uri()</code>, <code>absolute()</code>, <code>is_absolute()</code></li> </ul>"},{"location":"about/cloudpathlib-compat/#path-instantiation-testpathinstantiation","title":"\u2705 Path Instantiation (<code>TestPathInstantiation</code>)","text":"<ul> <li>Dispatch: <code>PanPath()</code> correctly routes to S3/GCS/Azure implementations</li> <li>Mode parameter: <code>mode=\"sync\"</code> vs <code>mode=\"async\"</code></li> <li>Error handling: Invalid modes, unsupported schemes</li> <li>Idempotency: <code>PanPath(PanPath(...))</code> preserves type</li> <li>Local paths: Dispatches to <code>LocalPath</code>/<code>AsyncLocalPath</code></li> </ul>"},{"location":"about/cloudpathlib-compat/#azure-scheme-aliases-testazureschemealiases","title":"\u2705 Azure Scheme Aliases (<code>TestAzureSchemeAliases</code>)","text":"<ul> <li>Both <code>az://</code> and <code>azure://</code> schemes supported</li> <li>Original scheme preserved in string representation</li> </ul>"},{"location":"about/cloudpathlib-compat/#type-preservation-testtypepreservation","title":"\u2705 Type Preservation (<code>TestTypePreservation</code>)","text":"<ul> <li><code>parent</code> returns same type as original path</li> <li><code>joinpath</code> and <code>/</code> operator preserve type</li> <li><code>with_suffix()</code>, <code>with_name()</code>, <code>with_stem()</code> preserve type</li> </ul>"},{"location":"about/cloudpathlib-compat/#string-operations-teststringoperations","title":"\u2705 String Operations (<code>TestStringOperations</code>)","text":"<ul> <li>Proper URI format with double slashes: <code>s3://bucket/key</code></li> <li><code>__repr__</code> includes class name and path</li> <li><code>__fspath__</code> returns string representation</li> </ul>"},{"location":"about/cloudpathlib-compat/#cross-platform-testcrossplatform","title":"\u2705 Cross-Platform (<code>TestCrossPlatform</code>)","text":"<ul> <li>Tests verify operations work identically across S3, GCS, and Azure</li> </ul>"},{"location":"about/cloudpathlib-compat/#path-comparison-testpathcomparison","title":"\u2705 Path Comparison (<code>TestPathComparison</code>)","text":"<ul> <li>Different buckets/containers not equal</li> <li>Different providers not equal</li> <li>Sync vs async paths not equal</li> <li>Same paths are equal with consistent hashing</li> </ul>"},{"location":"about/cloudpathlib-compat/#architecture-differences","title":"Architecture Differences","text":""},{"location":"about/cloudpathlib-compat/#panpath-vs-cloudpathlib","title":"PanPath vs cloudpathlib","text":"Feature PanPath cloudpathlib Routing Metaclass (<code>PanPathMeta</code>) Class hierarchy Sync/Async Separate classes (<code>PanPath</code>, <code>AsyncPanPath</code>) Single class with internal handling Caching Not implemented <code>FileCacheMode</code> support Client management Lazy client creation, registry-based Client instances with providers Local paths Explicit <code>LocalPath</code>/<code>AsyncLocalPath</code> No local path support"},{"location":"about/cloudpathlib-compat/#whats-compatible","title":"What's Compatible","text":"<p>\u2705 Path operations: All pathlib-like operations (joinpath, parent, with_suffix, etc.) \u2705 Cloud properties: <code>cloud_prefix</code>, <code>key</code> \u2705 File I/O: <code>read_text()</code>, <code>write_text()</code>, <code>read_bytes()</code>, <code>write_bytes()</code> \u2705 Path queries: <code>exists()</code>, <code>is_file()</code>, <code>is_dir()</code>, <code>stat()</code> \u2705 Directory operations: <code>iterdir()</code> (sync), <code>iterdir()</code> returns list (async) \u2705 Pattern matching: <code>match()</code> with glob patterns \u2705 URI operations: <code>as_uri()</code>, <code>__str__</code>, <code>__fspath__</code> \u2705 Equality and comparison: <code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>hash()</code></p>"},{"location":"about/cloudpathlib-compat/#whats-different","title":"What's Different","text":"<p>\u274c Caching: PanPath doesn't implement file caching (no <code>FileCacheMode</code>) \u274c Test rigs: cloudpathlib uses <code>CloudProviderTestRig</code> pattern; PanPath uses simpler mocking \u274c Mock clients: cloudpathlib has filesystem-based SDK mocks; PanPath mocks at sys.modules level \u26a0\ufe0f Async iterdir: PanPath's async version returns a list, not an async generator \u26a0\ufe0f Client API: Different client initialization and configuration</p>"},{"location":"about/cloudpathlib-compat/#test-results","title":"Test Results","text":"<pre><code>tests/test_cloudpath_compat.py::TestPathManipulation          12/12 passed \u2705\ntests/test_cloudpath_compat.py::TestPathInstantiation         6/6 passed   \u2705\ntests/test_cloudpath_compat.py::TestAzureSchemeAliases        2/2 passed   \u2705\ntests/test_cloudpath_compat.py::TestTypePreservation          4/4 passed   \u2705\ntests/test_cloudpath_compat.py::TestStringOperations          3/3 passed   \u2705\ntests/test_cloudpath_compat.py::TestCrossPlatform             1/1 passed   \u2705\ntests/test_cloudpath_compat.py::TestPathComparison            3/3 passed   \u2705\n\nTotal: 31/31 tests passed \u2705\n</code></pre>"},{"location":"about/cloudpathlib-compat/#migration-from-cloudpathlib","title":"Migration from cloudpathlib","text":"<p>If you're migrating from cloudpathlib to PanPath:</p>"},{"location":"about/cloudpathlib-compat/#these-work-identically","title":"\u2705 These work identically:","text":"<pre><code># Path creation\npath = PanPath(\"s3://bucket/key.txt\")  # Same as CloudPath\n\n# Path operations\nparent = path.parent\nnew_path = path / \"subdir\" / \"file.txt\"\nrenamed = path.with_suffix(\".md\")\n\n# File I/O\ncontent = path.read_text()\npath.write_text(\"data\")\n\n# Properties\nbucket = path.cloud_prefix  # \"s3://bucket\"\nkey = path.key              # \"key.txt\"\n</code></pre>"},{"location":"about/cloudpathlib-compat/#these-need-changes","title":"\u26a0\ufe0f These need changes:","text":"<pre><code># Async operations - use AsyncPanPath or mode=\"async\"\n# cloudpathlib: async with CloudPath(...).open() as f:\n# PanPath:\nasync_path = AsyncPanPath(\"s3://bucket/key.txt\")\n# or\nasync_path = PanPath(\"s3://bucket/key.txt\", mode=\"async\")\n\n# Async iterdir returns list, not async generator\n# cloudpathlib: async for item in path.iterdir():\n# PanPath:\nitems = await async_path.iterdir()\nfor item in items:\n    ...\n\n# No caching support\n# cloudpathlib: path.fspath  # Returns local cached path\n# PanPath: Not supported - use read_bytes()/write_bytes() directly\n</code></pre>"},{"location":"about/cloudpathlib-compat/#implementation-notes","title":"Implementation Notes","text":""},{"location":"about/cloudpathlib-compat/#methods-added-for-compatibility","title":"Methods Added for Compatibility","text":"<p>To ensure cloudpathlib compatibility, we added these methods to <code>CloudPath</code> and <code>AsyncCloudPath</code>:</p> <ul> <li><code>absolute()</code> - Returns self (cloud paths are always absolute)</li> <li><code>is_absolute()</code> - Always returns True</li> <li><code>as_uri()</code> - Returns the string representation (already a URI)</li> <li><code>match(pattern)</code> - Glob pattern matching against the key portion</li> </ul>"},{"location":"about/cloudpathlib-compat/#match-pattern-implementation","title":"Match Pattern Implementation","text":"<p>The <code>match()</code> method was specifically adapted for cloud paths: - Matches against the key portion only (excluding scheme and bucket) - Supports <code>**</code> recursive patterns - Uses <code>PurePosixPath.match()</code> internally for correct glob behavior</p> <p>Example: <pre><code>path = PanPath(\"s3://bucket/dir/subdir/file.py\")\npath.match(\"**/*.py\")      # True - matches file.py anywhere\npath.match(\"**/subdir/*\")  # True - matches in subdir\npath.match(\"dir/*/file.py\") # True - matches with wildcard\n</code></pre></p>"},{"location":"about/cloudpathlib-compat/#coverage-impact","title":"Coverage Impact","text":"<p>Adding cloudpathlib compatibility tests increased: - Total tests: 70 \u2192 101 tests (+44%) - Code coverage: 52% \u2192 53% - <code>base.py</code> coverage: 72% \u2192 73%</p>"},{"location":"about/cloudpathlib-compat/#future-enhancements","title":"Future Enhancements","text":"<p>Potential areas for further cloudpathlib compatibility:</p> <ol> <li>Caching support - Implement <code>FileCacheMode</code> and local caching</li> <li>Glob operations - Add <code>glob()</code>, <code>rglob()</code> methods</li> <li>Walk operations - Add <code>walk()</code> method for directory traversal</li> <li>Copy/upload operations - Add <code>copy()</code>, <code>upload_from()</code> methods</li> <li>Async generators - Make <code>iterdir()</code> an async generator for consistency</li> </ol>"},{"location":"about/cloudpathlib-compat/#references","title":"References","text":"<ul> <li>cloudpathlib GitHub</li> <li>cloudpathlib Documentation</li> </ul>"},{"location":"about/contributing/","title":"Contributing to PanPath","text":"<p>Thank you for your interest in contributing to PanPath! This guide will help you get started.</p>"},{"location":"about/contributing/#code-of-conduct","title":"Code of Conduct","text":"<p>Be respectful and inclusive. We welcome contributions from everyone.</p>"},{"location":"about/contributing/#getting-started","title":"Getting Started","text":""},{"location":"about/contributing/#1-fork-and-clone","title":"1. Fork and Clone","text":"<pre><code># Fork on GitHub, then clone your fork\ngit clone https://github.com/YOUR_USERNAME/panpath.git\ncd panpath\n</code></pre>"},{"location":"about/contributing/#2-set-up-development-environment","title":"2. Set Up Development Environment","text":"<pre><code># Create virtual environment\npython -m venv venv\nsource venv/bin/activate  # On Windows: venv\\Scripts\\activate\n\n# Install development dependencies\npip install -e .[all,dev,docs]\n</code></pre>"},{"location":"about/contributing/#3-create-a-branch","title":"3. Create a Branch","text":"<pre><code>git checkout -b feature/your-feature-name\n# or\ngit checkout -b fix/your-bug-fix\n</code></pre>"},{"location":"about/contributing/#development-workflow","title":"Development Workflow","text":""},{"location":"about/contributing/#running-tests","title":"Running Tests","text":"<pre><code># Run all tests\npytest\n\n# Run with coverage\npytest --cov=panpath --cov-report=html\n\n# Run specific test file\npytest tests/test_s3.py\n\n# Run specific test\npytest tests/test_s3.py::test_read_text\n</code></pre>"},{"location":"about/contributing/#type-checking","title":"Type Checking","text":"<pre><code># Run mypy\nmypy panpath\n</code></pre>"},{"location":"about/contributing/#code-formatting","title":"Code Formatting","text":"<pre><code># Format with black\nblack panpath tests\n\n# Check formatting\nblack --check panpath tests\n</code></pre>"},{"location":"about/contributing/#linting","title":"Linting","text":"<pre><code># Run ruff\nruff check panpath tests\n\n# Auto-fix issues\nruff check --fix panpath tests\n</code></pre>"},{"location":"about/contributing/#building-documentation","title":"Building Documentation","text":"<pre><code># Serve docs locally\nmkdocs serve\n\n# Build docs\nmkdocs build\n\n# Deploy to GitHub Pages (maintainers only)\nmkdocs gh-deploy\n</code></pre>"},{"location":"about/contributing/#project-structure","title":"Project Structure","text":"<pre><code>panpath/\n\u251c\u2500\u2500 panpath/           # Source code\n\u2502   \u251c\u2500\u2500 __init__.py      # Package exports\n\u2502   \u251c\u2500\u2500 base.py          # Base path classes\n\u2502   \u251c\u2500\u2500 router.py        # PanPath router\n\u2502   \u251c\u2500\u2500 registry.py      # Path class registry\n\u2502   \u251c\u2500\u2500 clients.py       # Client management\n\u2502   \u251c\u2500\u2500 exceptions.py    # Custom exceptions\n\u2502   \u251c\u2500\u2500 local_sync.py    # Local sync paths\n\u2502   \u251c\u2500\u2500 local_async.py   # Local async paths\n\u2502   \u251c\u2500\u2500 s3_sync.py       # S3 sync paths\n\u2502   \u251c\u2500\u2500 s3_async.py      # S3 async paths\n\u2502   \u251c\u2500\u2500 gs_sync.py       # GCS sync paths\n\u2502   \u251c\u2500\u2500 gs_async.py      # GCS async paths\n\u2502   \u251c\u2500\u2500 azure_sync.py    # Azure sync paths\n\u2502   \u2514\u2500\u2500 azure_async.py   # Azure async paths\n\u251c\u2500\u2500 tests/               # Test suite\n\u251c\u2500\u2500 docs/                # Documentation\n\u251c\u2500\u2500 examples/            # Example scripts\n\u2514\u2500\u2500 pyproject.toml       # Project configuration\n</code></pre>"},{"location":"about/contributing/#adding-features","title":"Adding Features","text":""},{"location":"about/contributing/#adding-a-new-method","title":"Adding a New Method","text":"<ol> <li> <p>Add to base classes (<code>base.py</code>):    <pre><code>class CloudPath:\n    def new_method(self, arg: str) -&gt; str:\n        \"\"\"New method implementation.\"\"\"\n        raise NotImplementedError\n</code></pre></p> </li> <li> <p>Implement in each backend (e.g., <code>s3_sync.py</code>):    <pre><code>class S3Path(CloudPath):\n    def new_method(self, arg: str) -&gt; str:\n        \"\"\"S3-specific implementation.\"\"\"\n        # Implementation here\n</code></pre></p> </li> <li> <p>Add async version (<code>s3_async.py</code>):    <pre><code>class AsyncS3Path(AsyncCloudPath):\n    async def new_method(self, arg: str) -&gt; str:\n        \"\"\"Async S3 implementation.\"\"\"\n        # Async implementation here\n</code></pre></p> </li> <li> <p>Write tests (<code>tests/test_s3.py</code>):    <pre><code>def test_new_method():\n    path = PanPath(\"s3://bucket/file.txt\")\n    result = path.new_method(\"arg\")\n    assert result == \"expected\"\n\nasync def test_new_method_async():\n    path = AsyncPanPath(\"s3://bucket/file.txt\")\n    result = await path.new_method(\"arg\")\n    assert result == \"expected\"\n</code></pre></p> </li> </ol>"},{"location":"about/contributing/#adding-a-new-backend","title":"Adding a New Backend","text":"<ol> <li>Create sync implementation (<code>new_backend_sync.py</code>)</li> <li>Create async implementation (<code>new_backend_async.py</code>)</li> <li>Create client (<code>new_backend_client.py</code>)</li> <li>Register in <code>__init__.py</code></li> <li>Add tests</li> <li>Update documentation</li> </ol>"},{"location":"about/contributing/#testing-guidelines","title":"Testing Guidelines","text":""},{"location":"about/contributing/#writing-tests","title":"Writing Tests","text":"<ul> <li>Use descriptive test names: <code>test_read_text_returns_content</code></li> <li>Test both sync and async versions</li> <li>Test error conditions</li> <li>Use fixtures for common setup</li> </ul>"},{"location":"about/contributing/#test-organization","title":"Test Organization","text":"<pre><code>import pytest\nfrom panpath import PanPath, AsyncPanPath\n\nclass TestS3Path:\n    \"\"\"Tests for S3Path.\"\"\"\n\n    def test_read_text(self):\n        \"\"\"Test reading text from S3.\"\"\"\n        path = PanPath(\"s3://bucket/file.txt\")\n        # Test implementation\n\n    @pytest.mark.asyncio\n    async def test_read_text_async(self):\n        \"\"\"Test async reading text from S3.\"\"\"\n        path = AsyncPanPath(\"s3://bucket/file.txt\")\n        # Test implementation\n</code></pre>"},{"location":"about/contributing/#mocking","title":"Mocking","text":"<p>Use mocking for external services:</p> <pre><code>import pytest\nfrom unittest.mock import Mock, patch\n\n@patch('boto3.client')\ndef test_s3_with_mock(mock_boto3):\n    \"\"\"Test S3 with mocked boto3.\"\"\"\n    mock_client = Mock()\n    mock_boto3.return_value = mock_client\n\n    # Test implementation\n</code></pre>"},{"location":"about/contributing/#documentation","title":"Documentation","text":""},{"location":"about/contributing/#docstring-style","title":"Docstring Style","text":"<p>Use Google-style docstrings:</p> <pre><code>def read_text(self, encoding: str = \"utf-8\") -&gt; str:\n    \"\"\"Read file content as text.\n\n    Args:\n        encoding: Text encoding to use. Defaults to \"utf-8\".\n\n    Returns:\n        File content as string.\n\n    Raises:\n        PathNotFoundError: If file doesn't exist.\n        PermissionError: If access is denied.\n\n    Example:\n        &gt;&gt;&gt; path = PanPath(\"s3://bucket/file.txt\")\n        &gt;&gt;&gt; content = path.read_text()\n        &gt;&gt;&gt; print(content)\n        Hello, World!\n    \"\"\"\n    # Implementation\n</code></pre>"},{"location":"about/contributing/#adding-documentation-pages","title":"Adding Documentation Pages","text":"<ol> <li>Create markdown file in <code>docs/</code></li> <li>Add to navigation in <code>mkdocs.yml</code></li> <li>Use consistent formatting</li> <li>Include code examples</li> <li>Add cross-references</li> </ol>"},{"location":"about/contributing/#pull-request-process","title":"Pull Request Process","text":""},{"location":"about/contributing/#1-prepare-your-changes","title":"1. Prepare Your Changes","text":"<pre><code># Make sure tests pass\npytest\n\n# Format code\nblack panpath tests\n\n# Check types\nmypy panpath\n\n# Lint\nruff check panpath tests\n</code></pre>"},{"location":"about/contributing/#2-commit-your-changes","title":"2. Commit Your Changes","text":"<p>Use conventional commit messages:</p> <pre><code># Features\ngit commit -m \"feat: add support for symlinks\"\n\n# Bug fixes\ngit commit -m \"fix: correct path resolution on Windows\"\n\n# Documentation\ngit commit -m \"docs: add examples for async usage\"\n\n# Tests\ngit commit -m \"test: add tests for glob patterns\"\n\n# Refactoring\ngit commit -m \"refactor: simplify client management\"\n</code></pre>"},{"location":"about/contributing/#3-push-and-create-pr","title":"3. Push and Create PR","text":"<pre><code>git push origin feature/your-feature-name\n</code></pre> <p>Then create a pull request on GitHub with:</p> <ul> <li>Clear title and description</li> <li>Reference any related issues</li> <li>Include tests and documentation</li> <li>Ensure CI passes</li> </ul>"},{"location":"about/contributing/#4-review-process","title":"4. Review Process","text":"<ul> <li>Maintainers will review your PR</li> <li>Address any feedback</li> <li>Once approved, it will be merged</li> </ul>"},{"location":"about/contributing/#release-process","title":"Release Process","text":"<p>(For maintainers)</p> <ol> <li>Update version in <code>pyproject.toml</code></li> <li>Update <code>CHANGELOG.md</code></li> <li>Create git tag: <code>git tag v0.x.0</code></li> <li>Push tag: <code>git push --tags</code></li> <li>GitHub Actions will build and publish to PyPI</li> </ol>"},{"location":"about/contributing/#getting-help","title":"Getting Help","text":"<ul> <li>Issues: GitHub Issues</li> <li>Discussions: GitHub Discussions</li> <li>Documentation: This site</li> </ul>"},{"location":"about/contributing/#recognition","title":"Recognition","text":"<p>Contributors will be:</p> <ul> <li>Listed in <code>CONTRIBUTORS.md</code></li> <li>Mentioned in release notes</li> <li>Acknowledged in documentation</li> </ul> <p>Thank you for contributing to PanPath! \ud83c\udf89</p>"},{"location":"about/license/","title":"License","text":""},{"location":"about/license/#mit-license","title":"MIT License","text":"<p>Copyright \u00a9 2025 panpath contributors</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"about/license/#third-party-licenses","title":"Third-Party Licenses","text":"<p>PanPath depends on several open-source libraries. Below are their licenses:</p>"},{"location":"about/license/#core-dependencies","title":"Core Dependencies","text":"<ul> <li>typing-extensions - Python Software Foundation License</li> </ul>"},{"location":"about/license/#optional-cloud-dependencies","title":"Optional Cloud Dependencies","text":"<ul> <li>boto3 (S3 sync) - Apache License 2.0</li> <li>aioboto3 (S3 async) - Apache License 2.0</li> <li>google-cloud-storage (GCS sync) - Apache License 2.0</li> <li>gcloud-aio-storage (GCS async) - MIT License</li> <li>azure-storage-blob (Azure) - MIT License</li> <li>aiofiles (async file I/O) - Apache License 2.0</li> </ul>"},{"location":"about/license/#development-dependencies","title":"Development Dependencies","text":"<ul> <li>pytest - MIT License</li> <li>mypy - MIT License</li> <li>black - MIT License</li> <li>ruff - MIT License</li> </ul>"},{"location":"about/license/#documentation-dependencies","title":"Documentation Dependencies","text":"<ul> <li>mkdocs - BSD License</li> <li>mkdocs-material - MIT License</li> <li>mkdocstrings - ISC License</li> </ul>"},{"location":"about/license/#attribution","title":"Attribution","text":"<p>PanPath is inspired by:</p> <ul> <li>pathlib - Python's standard library for filesystem paths</li> <li>cloudpathlib - Path-like interface for cloud storage</li> </ul> <p>We are grateful to the maintainers and contributors of these projects.</p>"},{"location":"about/license/#contributing","title":"Contributing","text":"<p>By contributing to PanPath, you agree that your contributions will be licensed under the MIT License.</p> <p>See CONTRIBUTING.md for more information.</p>"},{"location":"about/license/#questions","title":"Questions?","text":"<p>If you have questions about licensing, please open an issue or contact the maintainers.</p>"},{"location":"advanced/configuration/","title":"Configuration","text":"<p>Advanced configuration options for PanPath.</p>"},{"location":"advanced/configuration/#environment-variables","title":"Environment Variables","text":""},{"location":"advanced/configuration/#aws-s3","title":"AWS S3","text":"<pre><code>export AWS_ACCESS_KEY_ID=your_key\nexport AWS_SECRET_ACCESS_KEY=your_secret\nexport AWS_DEFAULT_REGION=us-east-1\n</code></pre>"},{"location":"advanced/configuration/#google-cloud","title":"Google Cloud","text":"<pre><code>export GOOGLE_APPLICATION_CREDENTIALS=/path/to/credentials.json\n</code></pre>"},{"location":"advanced/configuration/#azure","title":"Azure","text":"<pre><code>export AZURE_STORAGE_CONNECTION_STRING=your_connection_string\n</code></pre>"},{"location":"advanced/configuration/#custom-clients","title":"Custom Clients","text":"<pre><code>from panpath import PanPath\nfrom panpath.clients import get_s3_client\n\n# Configure S3 client\nget_s3_client(\n    aws_access_key_id=\"key\",\n    aws_secret_access_key=\"secret\",\n    region_name=\"us-west-2\"\n)\n\n# Use configured client\npath = PanPath(\"s3://bucket/file.txt\")\n</code></pre>"},{"location":"advanced/configuration/#see-also","title":"See Also","text":"<ul> <li>Provider Documentation - Provider-specific config</li> <li>Custom Clients - Advanced client management</li> </ul>"},{"location":"advanced/custom-clients/","title":"Custom Clients","text":"<p>Advanced client management and customization.</p>"},{"location":"advanced/custom-clients/#getting-clients","title":"Getting Clients","text":"<pre><code>from panpath.clients import get_s3_client, get_gs_client, get_azure_client\n\n# Get or create S3 client\ns3_client = get_s3_client(\n    aws_access_key_id=\"key\",\n    aws_secret_access_key=\"secret\"\n)\n\n# Get or create GCS client\ngs_client = get_gs_client()\n\n# Get or create Azure client\nazure_client = get_azure_client(\n    connection_string=\"connection_string\"\n)\n</code></pre>"},{"location":"advanced/custom-clients/#custom-endpoints","title":"Custom Endpoints","text":"<p>For S3-compatible services:</p> <pre><code>from panpath.clients import get_s3_client\n\n# MinIO\nget_s3_client(\n    endpoint_url=\"http://localhost:9000\",\n    aws_access_key_id=\"minioadmin\",\n    aws_secret_access_key=\"minioadmin\"\n)\n</code></pre>"},{"location":"advanced/custom-clients/#see-also","title":"See Also","text":"<ul> <li>Configuration - Basic configuration</li> <li>Provider Documentation - Provider specifics</li> </ul>"},{"location":"advanced/performance/","title":"Performance","text":"<p>Optimization tips and best practices for PanPath.</p>"},{"location":"advanced/performance/#use-async-for-concurrency","title":"Use Async for Concurrency","text":"<pre><code># Slow: Sequential\nfrom panpath import PanPath\n\nfor i in range(100):\n    path = PanPath(f\"s3://bucket/file{i}.txt\")\n    content = path.read_text()\n\n# Fast: Concurrent\nfrom panpath import AsyncPanPath\nimport asyncio\n\nasync def read_all():\n    paths = [AsyncPanPath(f\"s3://bucket/file{i}.txt\") for i in range(100)]\n    contents = await asyncio.gather(*[p.read_text() for p in paths])\n    return contents\n\nasyncio.run(read_all())\n</code></pre>"},{"location":"advanced/performance/#server-side-operations","title":"Server-Side Operations","text":"<p>Use server-side operations when possible:</p> <pre><code>from panpath import PanPath\n\n# Fast: Server-side copy (no download/upload)\nsrc = PanPath(\"s3://bucket/file.txt\")\nsrc.copy(\"s3://bucket/backup/file.txt\")\n\n# Slow: Download then upload\ncontent = src.read_bytes()\ndst = PanPath(\"s3://bucket/backup/file.txt\")\ndst.write_bytes(content)\n</code></pre>"},{"location":"advanced/performance/#bulk-operations","title":"Bulk Operations","text":"<pre><code>from panpath import PanPath\n\n# Efficient: Single copytree operation\nsrc_dir = PanPath(\"s3://bucket/data/\")\nsrc_dir.copytree(\"s3://bucket/backup/\")\n\n# Inefficient: Individual copies\nfor file in src_dir.rglob(\"*\"):\n    if file.is_file():\n        rel_path = file.relative_to(src_dir)\n        file.copy(PanPath(\"s3://bucket/backup/\") / rel_path)\n</code></pre>"},{"location":"advanced/performance/#see-also","title":"See Also","text":"<ul> <li>Async Operations - Async patterns</li> <li>Bulk Operations - Efficient operations</li> </ul>"},{"location":"advanced/testing/","title":"Testing","text":"<p>Testing applications that use PanPath.</p>"},{"location":"advanced/testing/#using-local-paths-for-tests","title":"Using Local Paths for Tests","text":"<p>The simplest approach is to use local paths during testing:</p> <pre><code>import pytest\nfrom panpath import PanPath\n\ndef test_file_processing():\n    # Use local path instead of cloud\n    path = PanPath(\"/tmp/test-file.txt\")\n    path.write_text(\"test content\")\n\n    # Your processing logic\n    result = process_file(path)\n\n    assert result == expected\n\ndef process_file(path: PanPath) -&gt; str:\n    \"\"\"Works with both local and cloud paths.\"\"\"\n    content = path.read_text()\n    return content.upper()\n</code></pre>"},{"location":"advanced/testing/#mocking-cloud-clients","title":"Mocking Cloud Clients","text":"<p>For more advanced testing:</p> <pre><code>from unittest.mock import Mock, patch\nfrom panpath import PanPath\n\n@patch('panpath.clients.get_s3_client')\ndef test_s3_operation(mock_get_client):\n    mock_client = Mock()\n    mock_get_client.return_value = mock_client\n\n    # Test your code\n    path = PanPath(\"s3://bucket/file.txt\")\n    # ...\n</code></pre>"},{"location":"advanced/testing/#see-also","title":"See Also","text":"<ul> <li>Contributing - Development setup</li> <li>Quick Start - Basic usage</li> </ul>"},{"location":"api/async-pan-path/","title":"AsyncPanPath API","text":"<p>The async-only path class for PanPath.</p>"},{"location":"api/async-pan-path/#panpath.router.AsyncPanPath","title":"AsyncPanPath","text":"<pre><code>AsyncPanPath(path: Union[str, Path], **kwargs: Any)\n</code></pre> <p>Universal async path router (always returns async paths).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # Asynchronous local path\n&gt;&gt;&gt; path = AsyncPanPath(\"/local/file.txt\")\n&gt;&gt;&gt; await path.read_text()\n</code></pre> <pre><code>&gt;&gt;&gt; # Asynchronous S3 path\n&gt;&gt;&gt; path = AsyncPanPath(\"s3://bucket/key.txt\")\n&gt;&gt;&gt; await path.read_text()\n</code></pre> <p>This is never called due to metaclass, but needed for type hints.</p> Source code in <code>panpath/router.py</code> <pre><code>def __init__(self, path: Union[str, PathlibPath], **kwargs: Any):\n    \"\"\"This is never called due to metaclass, but needed for type hints.\"\"\"\n    pass\n</code></pre>"},{"location":"api/async-pan-path/#overview","title":"Overview","text":"<p><code>AsyncPanPath</code> is always asynchronous, unlike <code>PanPath</code> which can be either sync or async.</p> <pre><code>from panpath import AsyncPanPath\nimport asyncio\n\nasync def main():\n    # Always async\n    path = AsyncPanPath(\"s3://bucket/file.txt\")\n\n    # All operations are async\n    await path.write_text(\"content\")\n    content = await path.read_text()\n    exists = await path.exists()\n\nasyncio.run(main())\n</code></pre>"},{"location":"api/async-pan-path/#when-to-use","title":"When to Use","text":"<p>Use <code>AsyncPanPath</code> when: - You're always working in async context - You want type hints to guarantee async operations - You're building async applications (FastAPI, aiohttp, etc.)</p> <p>Use <code>PanPath</code> when: - You want flexibility (can be sync or async) - You're working with both sync and async code</p>"},{"location":"api/async-pan-path/#see-also","title":"See Also","text":"<ul> <li>PanPath - Main path class</li> <li>Async Operations Guide - Async patterns</li> </ul>"},{"location":"api/azure/","title":"Azure Paths API","text":"<p>API reference for Azure Blob Storage paths.</p>"},{"location":"api/azure/#panpath.azure_sync.AzureBlobPath","title":"AzureBlobPath","text":"<pre><code>AzureBlobPath(*args: Any, **kwargs: Any)\n</code></pre> <p>               Bases: <code>CloudPath</code></p> <p>Synchronous Azure Blob Storage path implementation.</p> Source code in <code>panpath/base.py</code> <pre><code>def __init__(self, *args: Any, **kwargs: Any) -&gt; None:\n    \"\"\"Initialize cloud path (client already handled in __new__()).\"\"\"\n    # Remove client from kwargs if present (already handled in __new__())\n    kwargs.pop('client', None)\n    # Python version compatibility for PurePosixPath.__init__():\n    # - Python 3.9: Fully initialized in __new__(), __init__() does nothing useful but passes args to object.__init__() which rejects them\n    # - Python 3.10-3.11: Similar to 3.9\n    # - Python 3.12+: Needs __init__(*args) to set _raw_paths, _drv, etc.\n    import sys\n    if sys.version_info &gt;= (3, 12):\n        # Python 3.12+ requires calling __init__ with args to set internal properties\n        super().__init__(*args)  # type: ignore\n</code></pre>"},{"location":"api/azure/#panpath.azure_async.AsyncAzureBlobPath","title":"AsyncAzureBlobPath","text":"<pre><code>AsyncAzureBlobPath(*args: Any, **kwargs: Any)\n</code></pre> <p>               Bases: <code>AsyncCloudPath</code></p> <p>Asynchronous Azure Blob Storage path implementation.</p> Source code in <code>panpath/base.py</code> <pre><code>def __init__(self, *args: Any, **kwargs: Any) -&gt; None:\n    \"\"\"Initialize async cloud path (client already handled in __new__()).\"\"\"\n    # Remove client from kwargs if present (already handled in __new__())\n    kwargs.pop('client', None)\n    # Python version compatibility for PurePosixPath.__init__():\n    # - Python 3.9: Fully initialized in __new__(), __init__() does nothing useful but passes args to object.__init__() which rejects them\n    # - Python 3.10-3.11: Similar to 3.9\n    # - Python 3.12+: Needs __init__(*args) to set _raw_paths, _drv, etc.\n    import sys\n    if sys.version_info &gt;= (3, 12):\n        # Python 3.12+ requires calling __init__ with args to set internal properties\n        super().__init__(*args)  # type: ignore\n</code></pre>"},{"location":"api/azure/#overview","title":"Overview","text":"<p>Azure paths provide access to Azure Blob Storage.</p>"},{"location":"api/azure/#sync-usage","title":"Sync Usage","text":"<pre><code>from panpath import PanPath\n\n# Both schemes work\npath = PanPath(\"az://container/file.txt\")\n# or\npath = PanPath(\"azure://container/file.txt\")\n\ncontent = path.read_text()\n</code></pre>"},{"location":"api/azure/#async-usage","title":"Async Usage","text":"<pre><code>from panpath import AsyncPanPath\n\npath = AsyncPanPath(\"az://container/file.txt\")\ncontent = await path.read_text()\n</code></pre>"},{"location":"api/azure/#see-also","title":"See Also","text":"<ul> <li>Azure Blob Storage Guide - Complete Azure guide</li> <li>PanPath - Main API</li> </ul>"},{"location":"api/exceptions/","title":"Exceptions API","text":"<p>API reference for PanPath exceptions.</p>"},{"location":"api/exceptions/#panpath.exceptions","title":"exceptions","text":"<p>Exception classes for panpath.</p>"},{"location":"api/exceptions/#overview","title":"Overview","text":"<p>PanPath defines custom exceptions for better error handling.</p>"},{"location":"api/exceptions/#exception-hierarchy","title":"Exception Hierarchy","text":"<pre><code>PanPathException (base)\n\u251c\u2500\u2500 PathNotFoundError\n\u251c\u2500\u2500 PermissionError\n\u2514\u2500\u2500 InvalidPathError\n</code></pre>"},{"location":"api/exceptions/#usage","title":"Usage","text":"<pre><code>from panpath import PanPath\nfrom panpath.exceptions import (\n    PanPathException,\n    PathNotFoundError,\n    PermissionError,\n)\n\ntry:\n    path = PanPath(\"s3://bucket/file.txt\")\n    content = path.read_text()\nexcept PathNotFoundError:\n    print(\"File not found\")\nexcept PermissionError:\n    print(\"Access denied\")\nexcept PanPathException as e:\n    print(f\"Other error: {e}\")\n</code></pre>"},{"location":"api/exceptions/#see-also","title":"See Also","text":"<ul> <li>Error Handling Guide - Error handling patterns</li> <li>PanPath - Main API</li> </ul>"},{"location":"api/gcs/","title":"GCS Paths API","text":"<p>API reference for Google Cloud Storage paths.</p>"},{"location":"api/gcs/#panpath.gs_sync.GSPath","title":"GSPath","text":"<pre><code>GSPath(*args: Any, **kwargs: Any)\n</code></pre> <p>               Bases: <code>CloudPath</code></p> <p>Synchronous Google Cloud Storage path implementation.</p> Source code in <code>panpath/base.py</code> <pre><code>def __init__(self, *args: Any, **kwargs: Any) -&gt; None:\n    \"\"\"Initialize cloud path (client already handled in __new__()).\"\"\"\n    # Remove client from kwargs if present (already handled in __new__())\n    kwargs.pop('client', None)\n    # Python version compatibility for PurePosixPath.__init__():\n    # - Python 3.9: Fully initialized in __new__(), __init__() does nothing useful but passes args to object.__init__() which rejects them\n    # - Python 3.10-3.11: Similar to 3.9\n    # - Python 3.12+: Needs __init__(*args) to set _raw_paths, _drv, etc.\n    import sys\n    if sys.version_info &gt;= (3, 12):\n        # Python 3.12+ requires calling __init__ with args to set internal properties\n        super().__init__(*args)  # type: ignore\n</code></pre>"},{"location":"api/gcs/#panpath.gs_async.AsyncGSPath","title":"AsyncGSPath","text":"<pre><code>AsyncGSPath(*args: Any, **kwargs: Any)\n</code></pre> <p>               Bases: <code>AsyncCloudPath</code></p> <p>Asynchronous Google Cloud Storage path implementation.</p> Source code in <code>panpath/base.py</code> <pre><code>def __init__(self, *args: Any, **kwargs: Any) -&gt; None:\n    \"\"\"Initialize async cloud path (client already handled in __new__()).\"\"\"\n    # Remove client from kwargs if present (already handled in __new__())\n    kwargs.pop('client', None)\n    # Python version compatibility for PurePosixPath.__init__():\n    # - Python 3.9: Fully initialized in __new__(), __init__() does nothing useful but passes args to object.__init__() which rejects them\n    # - Python 3.10-3.11: Similar to 3.9\n    # - Python 3.12+: Needs __init__(*args) to set _raw_paths, _drv, etc.\n    import sys\n    if sys.version_info &gt;= (3, 12):\n        # Python 3.12+ requires calling __init__ with args to set internal properties\n        super().__init__(*args)  # type: ignore\n</code></pre>"},{"location":"api/gcs/#overview","title":"Overview","text":"<p>GCS paths provide access to Google Cloud Storage.</p>"},{"location":"api/gcs/#sync-usage","title":"Sync Usage","text":"<pre><code>from panpath import PanPath\n\npath = PanPath(\"gs://bucket/file.txt\")\ncontent = path.read_text()\n</code></pre>"},{"location":"api/gcs/#async-usage","title":"Async Usage","text":"<pre><code>from panpath import AsyncPanPath\n\npath = AsyncPanPath(\"gs://bucket/file.txt\")\ncontent = await path.read_text()\n</code></pre>"},{"location":"api/gcs/#see-also","title":"See Also","text":"<ul> <li>Google Cloud Storage Guide - Complete GCS guide</li> <li>PanPath - Main API</li> </ul>"},{"location":"api/local/","title":"Local Paths API","text":"<p>API reference for local filesystem paths.</p>"},{"location":"api/local/#panpath.local_sync.LocalPath","title":"LocalPath","text":"<p>               Bases: <code>_ConcretePath</code></p> <p>Local filesystem path (drop-in replacement for pathlib.Path).</p> <p>Inherits from the concrete PosixPath or WindowsPath for full compatibility.</p>"},{"location":"api/local/#panpath.local_sync.LocalPath.__eq__","title":"__eq__","text":"<pre><code>__eq__(other)\n</code></pre> <p>Check equality - sync paths never equal async paths.</p> Source code in <code>panpath/local_sync.py</code> <pre><code>def __eq__(self, other):  # type: ignore\n    \"\"\"Check equality - sync paths never equal async paths.\"\"\"\n    from panpath.local_async import AsyncLocalPath\n\n    if isinstance(other, AsyncLocalPath):\n        return False\n    return super().__eq__(other)\n</code></pre>"},{"location":"api/local/#panpath.local_sync.LocalPath.__hash__","title":"__hash__","text":"<pre><code>__hash__() -&gt; int\n</code></pre> <p>Return hash of path.</p> Source code in <code>panpath/local_sync.py</code> <pre><code>def __hash__(self) -&gt; int:\n    \"\"\"Return hash of path.\"\"\"\n    return super().__hash__()\n</code></pre>"},{"location":"api/local/#panpath.local_async.AsyncLocalPath","title":"AsyncLocalPath","text":"<p>               Bases: <code>PurePath</code></p> <p>Asynchronous local filesystem path using aiofiles.</p> <p>Unlike LocalPath (which inherits from Path), this inherits from PurePath and provides async methods for I/O operations.</p>"},{"location":"api/local/#panpath.local_async.AsyncLocalPath.parent","title":"parent  <code>property</code>","text":"<pre><code>parent: AsyncLocalPath\n</code></pre> <p>Return parent directory.</p>"},{"location":"api/local/#panpath.local_async.AsyncLocalPath.__new__","title":"__new__","text":"<pre><code>__new__(*args: Any) -&gt; AsyncLocalPath\n</code></pre> <p>Create new AsyncLocalPath instance.</p> Source code in <code>panpath/local_async.py</code> <pre><code>def __new__(cls, *args: Any) -&gt; \"AsyncLocalPath\":\n    \"\"\"Create new AsyncLocalPath instance.\"\"\"\n    if not HAS_AIOFILES:\n        from panpath.exceptions import MissingDependencyError\n\n        raise MissingDependencyError(\n            backend=\"async local paths\",\n            package=\"aiofiles\",\n            extra=\"all-async\",\n        )\n    return super().__new__(cls, *args)  # type: ignore\n</code></pre>"},{"location":"api/local/#panpath.local_async.AsyncLocalPath.__truediv__","title":"__truediv__","text":"<pre><code>__truediv__(other: Any) -&gt; AsyncLocalPath\n</code></pre> <p>Join paths.</p> Source code in <code>panpath/local_async.py</code> <pre><code>def __truediv__(self, other: Any) -&gt; \"AsyncLocalPath\":\n    \"\"\"Join paths.\"\"\"\n    result = super().__truediv__(other)\n    return self.__class__(result)\n</code></pre>"},{"location":"api/local/#panpath.local_async.AsyncLocalPath.__rtruediv__","title":"__rtruediv__","text":"<pre><code>__rtruediv__(other: Any) -&gt; AsyncLocalPath\n</code></pre> <p>Right join paths.</p> Source code in <code>panpath/local_async.py</code> <pre><code>def __rtruediv__(self, other: Any) -&gt; \"AsyncLocalPath\":\n    \"\"\"Right join paths.\"\"\"\n    result = super().__rtruediv__(other)\n    return self.__class__(result)\n</code></pre>"},{"location":"api/local/#panpath.local_async.AsyncLocalPath.joinpath","title":"joinpath","text":"<pre><code>joinpath(*args: Any) -&gt; AsyncLocalPath\n</code></pre> <p>Join paths.</p> Source code in <code>panpath/local_async.py</code> <pre><code>def joinpath(self, *args: Any) -&gt; \"AsyncLocalPath\":\n    \"\"\"Join paths.\"\"\"\n    result = super().joinpath(*args)\n    return self.__class__(result)\n</code></pre>"},{"location":"api/local/#panpath.local_async.AsyncLocalPath.exists","title":"exists  <code>async</code>","text":"<pre><code>exists() -&gt; bool\n</code></pre> <p>Check if path exists.</p> Source code in <code>panpath/local_async.py</code> <pre><code>async def exists(self) -&gt; bool:\n    \"\"\"Check if path exists.\"\"\"\n    return await aiofiles.os.path.exists(str(self))\n</code></pre>"},{"location":"api/local/#panpath.local_async.AsyncLocalPath.is_file","title":"is_file  <code>async</code>","text":"<pre><code>is_file() -&gt; bool\n</code></pre> <p>Check if path is a file.</p> Source code in <code>panpath/local_async.py</code> <pre><code>async def is_file(self) -&gt; bool:\n    \"\"\"Check if path is a file.\"\"\"\n    return await aiofiles.os.path.isfile(str(self))\n</code></pre>"},{"location":"api/local/#panpath.local_async.AsyncLocalPath.is_dir","title":"is_dir  <code>async</code>","text":"<pre><code>is_dir() -&gt; bool\n</code></pre> <p>Check if path is a directory.</p> Source code in <code>panpath/local_async.py</code> <pre><code>async def is_dir(self) -&gt; bool:\n    \"\"\"Check if path is a directory.\"\"\"\n    return await aiofiles.os.path.isdir(str(self))\n</code></pre>"},{"location":"api/local/#panpath.local_async.AsyncLocalPath.read_bytes","title":"read_bytes  <code>async</code>","text":"<pre><code>read_bytes() -&gt; bytes\n</code></pre> <p>Read file as bytes.</p> Source code in <code>panpath/local_async.py</code> <pre><code>async def read_bytes(self) -&gt; bytes:\n    \"\"\"Read file as bytes.\"\"\"\n    async with aiofiles.open(str(self), mode=\"rb\") as f:\n        return await f.read()\n</code></pre>"},{"location":"api/local/#panpath.local_async.AsyncLocalPath.read_text","title":"read_text  <code>async</code>","text":"<pre><code>read_text(encoding: str = 'utf-8') -&gt; str\n</code></pre> <p>Read file as text.</p> Source code in <code>panpath/local_async.py</code> <pre><code>async def read_text(self, encoding: str = \"utf-8\") -&gt; str:\n    \"\"\"Read file as text.\"\"\"\n    async with aiofiles.open(str(self), mode=\"r\", encoding=encoding) as f:\n        return await f.read()\n</code></pre>"},{"location":"api/local/#panpath.local_async.AsyncLocalPath.write_bytes","title":"write_bytes  <code>async</code>","text":"<pre><code>write_bytes(data: bytes) -&gt; None\n</code></pre> <p>Write bytes to file.</p> Source code in <code>panpath/local_async.py</code> <pre><code>async def write_bytes(self, data: bytes) -&gt; None:\n    \"\"\"Write bytes to file.\"\"\"\n    async with aiofiles.open(str(self), mode=\"wb\") as f:\n        await f.write(data)\n</code></pre>"},{"location":"api/local/#panpath.local_async.AsyncLocalPath.write_text","title":"write_text  <code>async</code>","text":"<pre><code>write_text(data: str, encoding: str = 'utf-8') -&gt; None\n</code></pre> <p>Write text to file.</p> Source code in <code>panpath/local_async.py</code> <pre><code>async def write_text(self, data: str, encoding: str = \"utf-8\") -&gt; None:\n    \"\"\"Write text to file.\"\"\"\n    async with aiofiles.open(str(self), mode=\"w\", encoding=encoding) as f:\n        await f.write(data)\n</code></pre>"},{"location":"api/local/#panpath.local_async.AsyncLocalPath.unlink","title":"unlink  <code>async</code>","text":"<pre><code>unlink(missing_ok: bool = False) -&gt; None\n</code></pre> <p>Delete file.</p> Source code in <code>panpath/local_async.py</code> <pre><code>async def unlink(self, missing_ok: bool = False) -&gt; None:\n    \"\"\"Delete file.\"\"\"\n    try:\n        await aiofiles.os.remove(str(self))\n    except FileNotFoundError:\n        if not missing_ok:\n            raise\n</code></pre>"},{"location":"api/local/#panpath.local_async.AsyncLocalPath.mkdir","title":"mkdir  <code>async</code>","text":"<pre><code>mkdir(\n    mode: int = 511,\n    parents: bool = False,\n    exist_ok: bool = False,\n) -&gt; None\n</code></pre> <p>Create directory.</p> Source code in <code>panpath/local_async.py</code> <pre><code>async def mkdir(self, mode: int = 0o777, parents: bool = False, exist_ok: bool = False) -&gt; None:\n    \"\"\"Create directory.\"\"\"\n    if parents:\n        await aiofiles.os.makedirs(str(self), mode=mode, exist_ok=exist_ok)\n    else:\n        try:\n            await aiofiles.os.mkdir(str(self), mode=mode)\n        except FileExistsError:\n            if not exist_ok:\n                raise\n</code></pre>"},{"location":"api/local/#panpath.local_async.AsyncLocalPath.rmdir","title":"rmdir  <code>async</code>","text":"<pre><code>rmdir() -&gt; None\n</code></pre> <p>Remove empty directory.</p> Source code in <code>panpath/local_async.py</code> <pre><code>async def rmdir(self) -&gt; None:\n    \"\"\"Remove empty directory.\"\"\"\n    await aiofiles.os.rmdir(str(self))\n</code></pre>"},{"location":"api/local/#panpath.local_async.AsyncLocalPath.iterdir","title":"iterdir  <code>async</code>","text":"<pre><code>iterdir() -&gt; list[AsyncLocalPath]\n</code></pre> <p>List directory contents.</p> Source code in <code>panpath/local_async.py</code> <pre><code>async def iterdir(self) -&gt; list[\"AsyncLocalPath\"]:\n    \"\"\"List directory contents.\"\"\"\n    entries = await aiofiles.os.listdir(str(self))\n    return [self / entry for entry in entries]\n</code></pre>"},{"location":"api/local/#panpath.local_async.AsyncLocalPath.stat","title":"stat  <code>async</code>","text":"<pre><code>stat() -&gt; os.stat_result\n</code></pre> <p>Get file stats.</p> Source code in <code>panpath/local_async.py</code> <pre><code>async def stat(self) -&gt; os.stat_result:\n    \"\"\"Get file stats.\"\"\"\n    return await aiofiles.os.stat(str(self))\n</code></pre>"},{"location":"api/local/#panpath.local_async.AsyncLocalPath.open","title":"open","text":"<pre><code>open(\n    mode: str = \"r\",\n    buffering: int = -1,\n    encoding: Optional[str] = None,\n    errors: Optional[str] = None,\n    newline: Optional[str] = None,\n) -&gt; Any\n</code></pre> <p>Open file and return async file handle.</p> <p>Returns:</p> Type Description <code>Any</code> <p>Async file handle from aiofiles</p> Source code in <code>panpath/local_async.py</code> <pre><code>def open(\n    self,\n    mode: str = \"r\",\n    buffering: int = -1,\n    encoding: Optional[str] = None,\n    errors: Optional[str] = None,\n    newline: Optional[str] = None,\n) -&gt; Any:\n    \"\"\"Open file and return async file handle.\n\n    Returns:\n        Async file handle from aiofiles\n    \"\"\"\n    return aiofiles.open(\n        str(self),\n        mode=mode,\n        buffering=buffering,\n        encoding=encoding,\n        errors=errors,\n        newline=newline,\n    )\n</code></pre>"},{"location":"api/local/#panpath.local_async.AsyncLocalPath.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: Any) -&gt; bool\n</code></pre> <p>Check equality - async paths never equal sync paths.</p> Source code in <code>panpath/local_async.py</code> <pre><code>def __eq__(self, other: Any) -&gt; bool:\n    \"\"\"Check equality - async paths never equal sync paths.\"\"\"\n    from panpath.local_sync import LocalPath\n\n    if isinstance(other, (Path, LocalPath)):\n        return False\n    return super().__eq__(other)\n</code></pre>"},{"location":"api/local/#panpath.local_async.AsyncLocalPath.__hash__","title":"__hash__","text":"<pre><code>__hash__() -&gt; int\n</code></pre> <p>Return hash of path.</p> Source code in <code>panpath/local_async.py</code> <pre><code>def __hash__(self) -&gt; int:\n    \"\"\"Return hash of path.\"\"\"\n    return super().__hash__()\n</code></pre>"},{"location":"api/local/#overview","title":"Overview","text":"<p>Local paths provide pathlib-compatible interface for local filesystem operations.</p>"},{"location":"api/local/#sync-usage","title":"Sync Usage","text":"<pre><code>from panpath import PanPath\n\n# Automatically creates LocalPath\npath = PanPath(\"/tmp/file.txt\")\ncontent = path.read_text()\n</code></pre>"},{"location":"api/local/#async-usage","title":"Async Usage","text":"<pre><code>from panpath import AsyncPanPath\n\n# Automatically creates AsyncLocalPath\npath = AsyncPanPath(\"/tmp/file.txt\")\ncontent = await path.read_text()\n</code></pre>"},{"location":"api/local/#see-also","title":"See Also","text":"<ul> <li>Local Paths Guide - Usage guide</li> <li>PanPath - Main API</li> </ul>"},{"location":"api/pan-path/","title":"PanPath API","text":"<p>The main entry point for PanPath - a universal path class that works with local and cloud storage.</p>"},{"location":"api/pan-path/#panpath.router.PanPath","title":"PanPath","text":"<pre><code>PanPath(\n    path: Union[str, Path],\n    mode: str = \"sync\",\n    **kwargs: Any\n)\n</code></pre> <p>Universal path router supporting sync and async modes.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # Synchronous local path\n&gt;&gt;&gt; path = PanPath(\"/local/file.txt\")\n&gt;&gt;&gt; path.read_text()\n</code></pre> <pre><code>&gt;&gt;&gt; # Synchronous S3 path\n&gt;&gt;&gt; path = PanPath(\"s3://bucket/key.txt\")\n&gt;&gt;&gt; path.read_text()\n</code></pre> <pre><code>&gt;&gt;&gt; # Asynchronous S3 path\n&gt;&gt;&gt; path = PanPath(\"s3://bucket/key.txt\", mode=\"async\")\n&gt;&gt;&gt; await path.read_text()\n</code></pre> <p>This is never called due to metaclass, but needed for type hints.</p> Source code in <code>panpath/router.py</code> <pre><code>def __init__(self, path: Union[str, PathlibPath], mode: str = \"sync\", **kwargs: Any):\n    \"\"\"This is never called due to metaclass, but needed for type hints.\"\"\"\n    pass\n</code></pre>"},{"location":"api/pan-path/#overview","title":"Overview","text":"<p><code>PanPath</code> is the main class for working with paths in PanPath. It automatically routes to the appropriate backend based on the URI scheme and can operate in either synchronous or asynchronous mode.</p>"},{"location":"api/pan-path/#basic-usage","title":"Basic Usage","text":"<pre><code>from panpath import PanPath\n\n# Local path\nlocal = PanPath(\"/tmp/file.txt\")\ncontent = local.read_text()\n\n# S3 path (sync)\ns3 = PanPath(\"s3://bucket/key.txt\")\ncontent = s3.read_text()\n\n# S3 path (async)\ns3_async = PanPath(\"s3://bucket/key.txt\", mode=\"async\")\ncontent = await s3_async.read_text()\n</code></pre>"},{"location":"api/pan-path/#constructor","title":"Constructor","text":""},{"location":"api/pan-path/#__init__path-str-pathlike-mode-str-sync","title":"<code>__init__(path: str | PathLike, mode: str = \"sync\")</code>","text":"<p>Create a new PanPath instance.</p> <p>Parameters:</p> <ul> <li><code>path</code> (str | PathLike): The path as a string or path-like object. Can be:<ul> <li>Local path: <code>/path/to/file.txt</code> or <code>file:///path/to/file.txt</code></li> <li>S3: <code>s3://bucket/key</code></li> <li>GCS: <code>gs://bucket/path</code></li> <li>Azure: <code>az://container/path</code> or <code>azure://container/path</code></li> </ul> </li> <li><code>mode</code> (str, optional): Operation mode. Either <code>\"sync\"</code> (default) or <code>\"async\"</code>.</li> </ul> <p>Returns: An instance of the appropriate path class (LocalPath, S3Path, GSPath, etc.)</p> <p>Examples:</p> <pre><code># Sync mode (default)\npath = PanPath(\"s3://bucket/file.txt\")\n\n# Async mode\nasync_path = PanPath(\"s3://bucket/file.txt\", mode=\"async\")\n\n# Local path\nlocal = PanPath(\"/tmp/file.txt\")\n</code></pre>"},{"location":"api/pan-path/#path-properties","title":"Path Properties","text":""},{"location":"api/pan-path/#name","title":"<code>name</code>","text":"<p>The final component of the path.</p> <pre><code>path = PanPath(\"s3://bucket/dir/file.txt\")\nprint(path.name)  # \"file.txt\"\n</code></pre>"},{"location":"api/pan-path/#stem","title":"<code>stem</code>","text":"<p>The filename without the suffix.</p> <pre><code>path = PanPath(\"s3://bucket/file.tar.gz\")\nprint(path.stem)  # \"file.tar\"\n</code></pre>"},{"location":"api/pan-path/#suffix","title":"<code>suffix</code>","text":"<p>The file extension including the dot.</p> <pre><code>path = PanPath(\"s3://bucket/file.txt\")\nprint(path.suffix)  # \".txt\"\n</code></pre>"},{"location":"api/pan-path/#suffixes","title":"<code>suffixes</code>","text":"<p>A list of all file extensions.</p> <pre><code>path = PanPath(\"s3://bucket/file.tar.gz\")\nprint(path.suffixes)  # [\".tar\", \".gz\"]\n</code></pre>"},{"location":"api/pan-path/#parent","title":"<code>parent</code>","text":"<p>The logical parent of this path.</p> <pre><code>path = PanPath(\"s3://bucket/dir/file.txt\")\nprint(path.parent)  # s3://bucket/dir\n</code></pre>"},{"location":"api/pan-path/#parents","title":"<code>parents</code>","text":"<p>A sequence of logical ancestors.</p> <pre><code>path = PanPath(\"s3://bucket/a/b/c/file.txt\")\nfor parent in path.parents:\n    print(parent)\n# s3://bucket/a/b/c\n# s3://bucket/a/b\n# s3://bucket/a\n# s3://bucket\n</code></pre>"},{"location":"api/pan-path/#parts","title":"<code>parts</code>","text":"<p>A tuple of path components.</p> <pre><code>path = PanPath(\"s3://bucket/dir/file.txt\")\nprint(path.parts)  # (\"s3://bucket\", \"dir\", \"file.txt\")\n</code></pre>"},{"location":"api/pan-path/#reading-and-writing","title":"Reading and Writing","text":""},{"location":"api/pan-path/#read_textencoding-str-utf-8-str","title":"<code>read_text(encoding: str = \"utf-8\") -&gt; str</code>","text":"<p>Read file content as text.</p> <pre><code>path = PanPath(\"s3://bucket/file.txt\")\ncontent = path.read_text()\n\n# With encoding\ncontent = path.read_text(encoding=\"latin-1\")\n</code></pre>"},{"location":"api/pan-path/#read_bytes-bytes","title":"<code>read_bytes() -&gt; bytes</code>","text":"<p>Read file content as bytes.</p> <pre><code>path = PanPath(\"s3://bucket/image.png\")\ndata = path.read_bytes()\n</code></pre>"},{"location":"api/pan-path/#write_textdata-str-encoding-str-utf-8-int","title":"<code>write_text(data: str, encoding: str = \"utf-8\") -&gt; int</code>","text":"<p>Write text to file.</p> <pre><code>path = PanPath(\"s3://bucket/file.txt\")\npath.write_text(\"Hello, World!\")\n</code></pre>"},{"location":"api/pan-path/#write_bytesdata-bytes-int","title":"<code>write_bytes(data: bytes) -&gt; int</code>","text":"<p>Write bytes to file.</p> <pre><code>path = PanPath(\"s3://bucket/data.bin\")\npath.write_bytes(b\"\\x00\\x01\\x02\")\n</code></pre>"},{"location":"api/pan-path/#openmode-str-r-encoding-str-none-io","title":"<code>open(mode: str = \"r\", encoding: str = None) -&gt; IO</code>","text":"<p>Open file for reading or writing.</p> <pre><code>path = PanPath(\"s3://bucket/file.txt\")\n\n# Read\nwith path.open(\"r\") as f:\n    content = f.read()\n\n# Write\nwith path.open(\"w\") as f:\n    f.write(\"Hello\\n\")\n    f.write(\"World\\n\")\n</code></pre>"},{"location":"api/pan-path/#path-information","title":"Path Information","text":""},{"location":"api/pan-path/#exists-bool","title":"<code>exists() -&gt; bool</code>","text":"<p>Check if path exists.</p> <pre><code>path = PanPath(\"s3://bucket/file.txt\")\nif path.exists():\n    print(\"File exists\")\n</code></pre>"},{"location":"api/pan-path/#is_file-bool","title":"<code>is_file() -&gt; bool</code>","text":"<p>Check if path is a file.</p> <pre><code>if path.is_file():\n    print(\"It's a file\")\n</code></pre>"},{"location":"api/pan-path/#is_dir-bool","title":"<code>is_dir() -&gt; bool</code>","text":"<p>Check if path is a directory.</p> <pre><code>if path.is_dir():\n    print(\"It's a directory\")\n</code></pre>"},{"location":"api/pan-path/#stat-osstat_result","title":"<code>stat() -&gt; os.stat_result</code>","text":"<p>Get file metadata.</p> <pre><code>path = PanPath(\"s3://bucket/file.txt\")\nstat = path.stat()\nprint(f\"Size: {stat.st_size}\")\nprint(f\"Modified: {stat.st_mtime}\")\n</code></pre>"},{"location":"api/pan-path/#directory-operations","title":"Directory Operations","text":""},{"location":"api/pan-path/#iterdir-iteratorpanpath","title":"<code>iterdir() -&gt; Iterator[PanPath]</code>","text":"<p>Iterate over directory contents.</p> <pre><code>directory = PanPath(\"s3://bucket/data/\")\nfor item in directory.iterdir():\n    print(item)\n</code></pre>"},{"location":"api/pan-path/#globpattern-str-listpanpath","title":"<code>glob(pattern: str) -&gt; List[PanPath]</code>","text":"<p>Find paths matching a pattern.</p> <pre><code>directory = PanPath(\"s3://bucket/data/\")\n\n# All .txt files\ntxt_files = directory.glob(\"*.txt\")\n\n# Recursive search\nall_py_files = directory.glob(\"**/*.py\")\n</code></pre>"},{"location":"api/pan-path/#rglobpattern-str-listpanpath","title":"<code>rglob(pattern: str) -&gt; List[PanPath]</code>","text":"<p>Recursively find paths matching a pattern.</p> <pre><code>directory = PanPath(\"s3://bucket/\")\npy_files = directory.rglob(\"*.py\")\n# Equivalent to: directory.glob(\"**/*.py\")\n</code></pre>"},{"location":"api/pan-path/#walk-iteratortuplestr-liststr-liststr","title":"<code>walk() -&gt; Iterator[Tuple[str, List[str], List[str]]]</code>","text":"<p>Walk directory tree.</p> <pre><code>directory = PanPath(\"s3://bucket/data/\")\nfor dirpath, dirnames, filenames in directory.walk():\n    print(f\"Directory: {dirpath}\")\n    for filename in filenames:\n        print(f\"  {filename}\")\n</code></pre>"},{"location":"api/pan-path/#file-operations","title":"File Operations","text":""},{"location":"api/pan-path/#mkdirparents-bool-false-exist_ok-bool-false-none","title":"<code>mkdir(parents: bool = False, exist_ok: bool = False) -&gt; None</code>","text":"<p>Create a directory.</p> <pre><code>directory = PanPath(\"s3://bucket/new-dir/\")\ndirectory.mkdir(parents=True, exist_ok=True)\n</code></pre>"},{"location":"api/pan-path/#touchexist_ok-bool-true-none","title":"<code>touch(exist_ok: bool = True) -&gt; None</code>","text":"<p>Create an empty file.</p> <pre><code>path = PanPath(\"s3://bucket/empty.txt\")\npath.touch()\n</code></pre>"},{"location":"api/pan-path/#unlinkmissing_ok-bool-false-none","title":"<code>unlink(missing_ok: bool = False) -&gt; None</code>","text":"<p>Delete a file.</p> <pre><code>path = PanPath(\"s3://bucket/old.txt\")\npath.unlink()\n\n# Don't raise if missing\npath.unlink(missing_ok=True)\n</code></pre>"},{"location":"api/pan-path/#rmdir-none","title":"<code>rmdir() -&gt; None</code>","text":"<p>Remove an empty directory.</p> <pre><code>directory = PanPath(\"s3://bucket/empty-dir/\")\ndirectory.rmdir()\n</code></pre>"},{"location":"api/pan-path/#rmtree-none","title":"<code>rmtree() -&gt; None</code>","text":"<p>Remove directory and all contents.</p> <pre><code>directory = PanPath(\"s3://bucket/data/\")\ndirectory.rmtree()\n</code></pre>"},{"location":"api/pan-path/#renametarget-str-panpath-panpath","title":"<code>rename(target: str | PanPath) -&gt; PanPath</code>","text":"<p>Rename or move a file.</p> <pre><code>old = PanPath(\"s3://bucket/old.txt\")\nnew = old.rename(\"s3://bucket/new.txt\")\n</code></pre>"},{"location":"api/pan-path/#replacetarget-str-panpath-panpath","title":"<code>replace(target: str | PanPath) -&gt; PanPath</code>","text":"<p>Replace a file (same as rename for cloud storage).</p> <pre><code>path = PanPath(\"s3://bucket/file.txt\")\nnew = path.replace(\"s3://bucket/replaced.txt\")\n</code></pre>"},{"location":"api/pan-path/#bulk-operations","title":"Bulk Operations","text":""},{"location":"api/pan-path/#copydst-str-panpath-none","title":"<code>copy(dst: str | PanPath) -&gt; None</code>","text":"<p>Copy file to destination.</p> <pre><code>src = PanPath(\"s3://bucket/file.txt\")\nsrc.copy(\"gs://other/file.txt\")\n</code></pre>"},{"location":"api/pan-path/#copytreedst-str-panpath-none","title":"<code>copytree(dst: str | PanPath) -&gt; None</code>","text":"<p>Copy directory tree to destination.</p> <pre><code>src = PanPath(\"s3://bucket/data/\")\nsrc.copytree(\"gs://backup/data/\")\n</code></pre>"},{"location":"api/pan-path/#path-manipulation","title":"Path Manipulation","text":""},{"location":"api/pan-path/#joinpathparts-str-panpath","title":"<code>joinpath(*parts: str) -&gt; PanPath</code>","text":"<p>Join path components.</p> <pre><code>path = PanPath(\"s3://bucket/data\")\nnew = path.joinpath(\"subdir\", \"file.txt\")\n# s3://bucket/data/subdir/file.txt\n</code></pre>"},{"location":"api/pan-path/#with_namename-str-panpath","title":"<code>with_name(name: str) -&gt; PanPath</code>","text":"<p>Return path with different name.</p> <pre><code>path = PanPath(\"s3://bucket/old.txt\")\nnew = path.with_name(\"new.txt\")\n# s3://bucket/new.txt\n</code></pre>"},{"location":"api/pan-path/#with_stemstem-str-panpath","title":"<code>with_stem(stem: str) -&gt; PanPath</code>","text":"<p>Return path with different stem.</p> <pre><code>path = PanPath(\"s3://bucket/file.txt\")\nnew = path.with_stem(\"newfile\")\n# s3://bucket/newfile.txt\n</code></pre>"},{"location":"api/pan-path/#with_suffixsuffix-str-panpath","title":"<code>with_suffix(suffix: str) -&gt; PanPath</code>","text":"<p>Return path with different suffix.</p> <pre><code>path = PanPath(\"s3://bucket/file.txt\")\nnew = path.with_suffix(\".csv\")\n# s3://bucket/file.csv\n</code></pre>"},{"location":"api/pan-path/#pattern-matching","title":"Pattern Matching","text":""},{"location":"api/pan-path/#matchpattern-str-bool","title":"<code>match(pattern: str) -&gt; bool</code>","text":"<p>Match path against pattern.</p> <pre><code>path = PanPath(\"s3://bucket/data/file.txt\")\nprint(path.match(\"*.txt\"))  # True\nprint(path.match(\"**/data/*.txt\"))  # True\n</code></pre>"},{"location":"api/pan-path/#relative_toother-str-panpath-panpath","title":"<code>relative_to(other: str | PanPath) -&gt; PanPath</code>","text":"<p>Get relative path.</p> <pre><code>path = PanPath(\"s3://bucket/data/sub/file.txt\")\nbase = PanPath(\"s3://bucket/data/\")\nrel = path.relative_to(base)\n# sub/file.txt\n</code></pre>"},{"location":"api/pan-path/#is_relative_toother-str-panpath-bool","title":"<code>is_relative_to(other: str | PanPath) -&gt; bool</code>","text":"<p>Check if path is relative to another.</p> <pre><code>path = PanPath(\"s3://bucket/data/file.txt\")\nprint(path.is_relative_to(\"s3://bucket/data\"))  # True\nprint(path.is_relative_to(\"s3://other\"))  # False\n</code></pre>"},{"location":"api/pan-path/#other-methods","title":"Other Methods","text":""},{"location":"api/pan-path/#resolve-panpath","title":"<code>resolve() -&gt; PanPath</code>","text":"<p>Return absolute path (no-op for cloud paths).</p> <pre><code>path = PanPath(\"s3://bucket/file.txt\")\nresolved = path.resolve()\n# Same as path for cloud storage\n</code></pre>"},{"location":"api/pan-path/#absolute-panpath","title":"<code>absolute() -&gt; PanPath</code>","text":"<p>Return absolute path (no-op for cloud paths).</p> <pre><code>path = PanPath(\"s3://bucket/file.txt\")\nabsolute = path.absolute()\n# Same as path for cloud storage\n</code></pre>"},{"location":"api/pan-path/#as_uri-str","title":"<code>as_uri() -&gt; str</code>","text":"<p>Return path as URI.</p> <pre><code>path = PanPath(\"s3://bucket/file.txt\")\nprint(path.as_uri())  # \"s3://bucket/file.txt\"\n</code></pre>"},{"location":"api/pan-path/#see-also","title":"See Also","text":"<ul> <li>AsyncPanPath - Async-only path class</li> <li>Local Paths - Local filesystem paths</li> <li>S3 Paths - Amazon S3 paths</li> <li>GCS Paths - Google Cloud Storage paths</li> <li>Azure Paths - Azure Blob Storage paths</li> </ul>"},{"location":"api/s3/","title":"S3 Paths API","text":"<p>API reference for Amazon S3 paths.</p>"},{"location":"api/s3/#panpath.s3_sync.S3Path","title":"S3Path","text":"<pre><code>S3Path(*args: Any, **kwargs: Any)\n</code></pre> <p>               Bases: <code>CloudPath</code></p> <p>Synchronous S3 path implementation.</p> Source code in <code>panpath/base.py</code> <pre><code>def __init__(self, *args: Any, **kwargs: Any) -&gt; None:\n    \"\"\"Initialize cloud path (client already handled in __new__()).\"\"\"\n    # Remove client from kwargs if present (already handled in __new__())\n    kwargs.pop('client', None)\n    # Python version compatibility for PurePosixPath.__init__():\n    # - Python 3.9: Fully initialized in __new__(), __init__() does nothing useful but passes args to object.__init__() which rejects them\n    # - Python 3.10-3.11: Similar to 3.9\n    # - Python 3.12+: Needs __init__(*args) to set _raw_paths, _drv, etc.\n    import sys\n    if sys.version_info &gt;= (3, 12):\n        # Python 3.12+ requires calling __init__ with args to set internal properties\n        super().__init__(*args)  # type: ignore\n</code></pre>"},{"location":"api/s3/#panpath.s3_async.AsyncS3Path","title":"AsyncS3Path","text":"<pre><code>AsyncS3Path(*args: Any, **kwargs: Any)\n</code></pre> <p>               Bases: <code>AsyncCloudPath</code></p> <p>Asynchronous S3 path implementation.</p> Source code in <code>panpath/base.py</code> <pre><code>def __init__(self, *args: Any, **kwargs: Any) -&gt; None:\n    \"\"\"Initialize async cloud path (client already handled in __new__()).\"\"\"\n    # Remove client from kwargs if present (already handled in __new__())\n    kwargs.pop('client', None)\n    # Python version compatibility for PurePosixPath.__init__():\n    # - Python 3.9: Fully initialized in __new__(), __init__() does nothing useful but passes args to object.__init__() which rejects them\n    # - Python 3.10-3.11: Similar to 3.9\n    # - Python 3.12+: Needs __init__(*args) to set _raw_paths, _drv, etc.\n    import sys\n    if sys.version_info &gt;= (3, 12):\n        # Python 3.12+ requires calling __init__ with args to set internal properties\n        super().__init__(*args)  # type: ignore\n</code></pre>"},{"location":"api/s3/#overview","title":"Overview","text":"<p>S3 paths provide access to Amazon S3 storage.</p>"},{"location":"api/s3/#sync-usage","title":"Sync Usage","text":"<pre><code>from panpath import PanPath\n\npath = PanPath(\"s3://bucket/file.txt\")\ncontent = path.read_text()\n</code></pre>"},{"location":"api/s3/#async-usage","title":"Async Usage","text":"<pre><code>from panpath import AsyncPanPath\n\npath = AsyncPanPath(\"s3://bucket/file.txt\")\ncontent = await path.read_text()\n</code></pre>"},{"location":"api/s3/#see-also","title":"See Also","text":"<ul> <li>Amazon S3 Guide - Complete S3 guide</li> <li>PanPath - Main API</li> </ul>"},{"location":"getting-started/concepts/","title":"Basic Concepts","text":"<p>Understanding PanPath's architecture and design principles will help you use it effectively.</p>"},{"location":"getting-started/concepts/#core-principles","title":"Core Principles","text":""},{"location":"getting-started/concepts/#1-unified-interface","title":"1. Unified Interface","text":"<p>PanPath provides a single, consistent API that works across different storage backends:</p> <pre><code>from panpath import PanPath\n\n# All these use the same interface\nlocal = PanPath(\"/tmp/file.txt\")\ns3 = PanPath(\"s3://bucket/file.txt\")\ngcs = PanPath(\"gs://bucket/file.txt\")\nazure = PanPath(\"az://container/file.txt\")\n\n# Same operations work on all\nfor path in [local, s3, gcs, azure]:\n    path.write_text(\"Same API\")\n    content = path.read_text()\n    print(path.exists())\n</code></pre>"},{"location":"getting-started/concepts/#2-pathlib-compatibility","title":"2. Pathlib Compatibility","text":"<p>For local files, PanPath is a drop-in replacement for <code>pathlib.Path</code>:</p> <pre><code>from pathlib import Path\nfrom panpath import PanPath\n\n# These work identically for local paths\npathlib_path = Path(\"/tmp/file.txt\")\npan_path = PanPath(\"/tmp/file.txt\")\n\n# Same operations\npathlib_path.write_text(\"Hello\")\npan_path.write_text(\"Hello\")\n\n# Same properties\nassert pathlib_path.name == pan_path.name\nassert pathlib_path.suffix == pan_path.suffix\n</code></pre>"},{"location":"getting-started/concepts/#3-sync-and-async-modes","title":"3. Sync and Async Modes","text":"<p>Every path can be used in synchronous or asynchronous mode:</p> <pre><code>from panpath import PanPath, AsyncPanPath\n\n# Synchronous (blocks until complete)\nsync_path = PanPath(\"s3://bucket/file.txt\")\ncontent = sync_path.read_text()  # Blocks\n\n# Asynchronous (non-blocking)\nasync_path = PanPath(\"s3://bucket/file.txt\", mode=\"async\")\ncontent = await async_path.read_text()  # Non-blocking\n\n# AsyncPanPath is always async\nalways_async = AsyncPanPath(\"s3://bucket/file.txt\")\ncontent = await always_async.read_text()\n</code></pre>"},{"location":"getting-started/concepts/#architecture","title":"Architecture","text":""},{"location":"getting-started/concepts/#path-resolution","title":"Path Resolution","text":"<p>PanPath uses URI schemes to route to the appropriate backend:</p> <pre><code>graph TD\n    A[PanPath] --&gt; B{Parse URI}\n    B --&gt;|No scheme or file://| C[LocalPath]\n    B --&gt;|s3://| D[S3Path]\n    B --&gt;|gs://| E[GSPath]\n    B --&gt;|az:// or azure://| F[AzurePath]\n\n    C --&gt; G{Mode?}\n    D --&gt; G\n    E --&gt; G\n    F --&gt; G\n\n    G --&gt;|sync| H[Sync Implementation]\n    G --&gt;|async| I[Async Implementation]</code></pre>"},{"location":"getting-started/concepts/#client-management","title":"Client Management","text":"<p>Cloud clients are created lazily and reused:</p> <pre><code>from panpath import PanPath\n\n# First S3 path creates a client\npath1 = PanPath(\"s3://bucket1/file.txt\")\n\n# Second S3 path reuses the same client\npath2 = PanPath(\"s3://bucket2/file.txt\")\n\n# Different backend creates a different client\npath3 = PanPath(\"gs://bucket/file.txt\")\n</code></pre> <p>Performance</p> <p>Client reuse means you don't pay the initialization cost for each path instance.</p>"},{"location":"getting-started/concepts/#registry-system","title":"Registry System","text":"<p>Path classes are registered by URI scheme:</p> <pre><code>from panpath.registry import register_path_class, get_path_class\n\n# Registration (automatic for built-in backends)\nregister_path_class(\"s3\", S3Path, AsyncS3Path)\n\n# Retrieval (used internally)\nsync_class = get_path_class(\"s3\", mode=\"sync\")\nasync_class = get_path_class(\"s3\", mode=\"async\")\n</code></pre>"},{"location":"getting-started/concepts/#path-types","title":"Path Types","text":""},{"location":"getting-started/concepts/#panpath-vs-asyncpanpath","title":"PanPath vs AsyncPanPath","text":"<pre><code>from panpath import PanPath, AsyncPanPath\n\n# PanPath: mode can be specified\nsync = PanPath(\"s3://bucket/file.txt\", mode=\"sync\")   # Default\nasync1 = PanPath(\"s3://bucket/file.txt\", mode=\"async\")\n\n# AsyncPanPath: always async, mode parameter ignored\nasync2 = AsyncPanPath(\"s3://bucket/file.txt\")\n\n# Type checking\nisinstance(sync, PanPath)    # True\nisinstance(async1, PanPath)  # True (PanPath can be async)\nisinstance(async2, AsyncPanPath)  # True\n</code></pre> <p>When to use which?</p> <ul> <li>Use <code>PanPath</code> when you want flexibility (can be sync or async)</li> <li>Use <code>AsyncPanPath</code> when you're always working in async context</li> <li>In type hints, use <code>AsyncPanPath</code> to guarantee async operations</li> </ul>"},{"location":"getting-started/concepts/#type-preservation","title":"Type Preservation","text":"<p>Path operations preserve the type and mode:</p> <pre><code>from panpath import PanPath\n\n# Sync S3 path\nsync_path = PanPath(\"s3://bucket/data/file.txt\")\nsync_parent = sync_path.parent  # Still sync S3Path\nsync_sibling = sync_parent / \"other.txt\"  # Still sync S3Path\n\n# Async S3 path\nasync_path = PanPath(\"s3://bucket/data/file.txt\", mode=\"async\")\nasync_parent = async_path.parent  # Async S3Path\nasync_sibling = async_parent / \"other.txt\"  # Async S3Path\n</code></pre> <p>This means you can chain operations without worrying about type changes:</p> <pre><code>path = PanPath(\"s3://bucket/deep/nested/file.txt\", mode=\"async\")\n\n# All these preserve async mode\nnew_path = (path\n    .parent           # async\n    .parent           # async\n    / \"other\"         # async\n    / \"file.txt\")     # async\n\n# Still async!\nawait new_path.write_text(\"content\")\n</code></pre>"},{"location":"getting-started/concepts/#storage-concepts","title":"Storage Concepts","text":""},{"location":"getting-started/concepts/#local-paths","title":"Local Paths","text":"<p>Local paths represent files and directories on the filesystem:</p> <pre><code>from panpath import PanPath\n\npath = PanPath(\"/tmp/file.txt\")\n# or\npath = PanPath(\"file:///tmp/file.txt\")\n\n# Supports all pathlib operations\npath.resolve()\npath.absolute()\npath.expanduser()\n</code></pre>"},{"location":"getting-started/concepts/#cloud-paths","title":"Cloud Paths","text":"<p>Cloud paths use URI schemes to represent cloud storage objects:</p> <pre><code>from panpath import PanPath\n\n# Format: scheme://bucket_or_container/key_or_path\ns3 = PanPath(\"s3://my-bucket/path/to/object.txt\")\ngcs = PanPath(\"gs://my-bucket/path/to/object.txt\")\nazure = PanPath(\"az://my-container/path/to/blob.txt\")\n</code></pre> <p>Key differences from local paths:</p> <ul> <li>No absolute/relative distinction: All cloud paths are absolute</li> <li>No symlinks: Cloud storage doesn't support symbolic links</li> <li>Different permissions model: Uses cloud IAM instead of filesystem permissions</li> <li>No hard links: Each object is independent</li> </ul>"},{"location":"getting-started/concepts/#buckets-and-containers","title":"Buckets and Containers","text":"<p>The first component after the scheme is the bucket (S3/GCS) or container (Azure):</p> <pre><code>from panpath import PanPath\n\ns3_path = PanPath(\"s3://my-bucket/folder/file.txt\")\nprint(s3_path.parts)  # ('s3://my-bucket', 'folder', 'file.txt')\n\n# Cloud-specific properties\nprint(s3_path.cloud_prefix)  # s3://my-bucket\nprint(s3_path.key)           # folder/file.txt\n</code></pre>"},{"location":"getting-started/concepts/#operations","title":"Operations","text":""},{"location":"getting-started/concepts/#synchronous-operations","title":"Synchronous Operations","text":"<p>Block until completion:</p> <pre><code>from panpath import PanPath\n\npath = PanPath(\"s3://bucket/file.txt\")\n\n# These block the thread\ncontent = path.read_text()\npath.write_text(\"new content\")\nexists = path.exists()\nitems = list(path.iterdir())\n</code></pre> <p>Use when:</p> <ul> <li>Writing simple scripts</li> <li>Working in synchronous frameworks (Flask, Django)</li> <li>Operations are infrequent</li> <li>Code simplicity is more important than concurrency</li> </ul>"},{"location":"getting-started/concepts/#asynchronous-operations","title":"Asynchronous Operations","text":"<p>Return coroutines that can be awaited:</p> <pre><code>from panpath import AsyncPanPath\nimport asyncio\n\nasync def main():\n    path = AsyncPanPath(\"s3://bucket/file.txt\")\n\n    # These are non-blocking\n    content = await path.read_text()\n    await path.write_text(\"new content\")\n    exists = await path.exists()\n    items = await path.iterdir()\n\nasyncio.run(main())\n</code></pre> <p>Use when:</p> <ul> <li>Building async applications (FastAPI, aiohttp)</li> <li>Need high concurrency</li> <li>Performing many I/O operations</li> <li>Want better resource utilization</li> </ul>"},{"location":"getting-started/concepts/#parallel-async-operations","title":"Parallel Async Operations","text":"<p>Async mode enables concurrent operations:</p> <pre><code>import asyncio\nfrom panpath import AsyncPanPath\n\nasync def download_all(urls):\n    # Create async paths\n    paths = [AsyncPanPath(url) for url in urls]\n\n    # Download all concurrently\n    contents = await asyncio.gather(*[p.read_text() for p in paths])\n\n    return contents\n\nurls = [\n    \"s3://bucket/file1.txt\",\n    \"s3://bucket/file2.txt\",\n    \"s3://bucket/file3.txt\",\n]\nasyncio.run(download_all(urls))\n</code></pre>"},{"location":"getting-started/concepts/#error-handling","title":"Error Handling","text":""},{"location":"getting-started/concepts/#common-exceptions","title":"Common Exceptions","text":"<pre><code>from panpath import PanPath\nfrom panpath.exceptions import (\n    PanPathException,\n    PathNotFoundError,\n    PermissionError,\n)\n\npath = PanPath(\"s3://bucket/nonexistent.txt\")\n\ntry:\n    content = path.read_text()\nexcept PathNotFoundError:\n    print(\"File not found\")\nexcept PermissionError:\n    print(\"Access denied\")\nexcept PanPathException as e:\n    print(f\"Other error: {e}\")\n</code></pre>"},{"location":"getting-started/concepts/#backend-specific-errors","title":"Backend-Specific Errors","text":"<p>Cloud backends may raise provider-specific errors:</p> <pre><code>from panpath import PanPath\nimport botocore.exceptions\n\npath = PanPath(\"s3://bucket/file.txt\")\n\ntry:\n    content = path.read_text()\nexcept botocore.exceptions.NoCredentialsError:\n    print(\"AWS credentials not configured\")\nexcept botocore.exceptions.ClientError as e:\n    print(f\"AWS error: {e}\")\n</code></pre>"},{"location":"getting-started/concepts/#best-practices","title":"Best Practices","text":""},{"location":"getting-started/concepts/#1-use-type-hints","title":"1. Use Type Hints","text":"<pre><code>from panpath import PanPath, AsyncPanPath\nfrom pathlib import Path\n\ndef process_file(path: PanPath) -&gt; str:\n    \"\"\"Can be sync or async path.\"\"\"\n    return path.read_text()\n\nasync def process_async(path: AsyncPanPath) -&gt; str:\n    \"\"\"Must be async path.\"\"\"\n    return await path.read_text()\n\ndef process_local(path: Path | PanPath) -&gt; str:\n    \"\"\"Accept pathlib.Path or PanPath.\"\"\"\n    if isinstance(path, Path):\n        path = PanPath(str(path))\n    return path.read_text()\n</code></pre>"},{"location":"getting-started/concepts/#2-handle-optional-dependencies","title":"2. Handle Optional Dependencies","text":"<pre><code>from panpath import PanPath\n\ndef get_data(uri: str) -&gt; str:\n    try:\n        path = PanPath(uri)\n        return path.read_text()\n    except ImportError as e:\n        raise RuntimeError(\n            f\"Cloud backend not installed: {e}\\n\"\n            f\"Install with: pip install panpath[s3]\"\n        )\n</code></pre>"},{"location":"getting-started/concepts/#3-use-context-managers","title":"3. Use Context Managers","text":"<pre><code>from panpath import PanPath\n\n# Good: File is automatically closed\nwith PanPath(\"s3://bucket/file.txt\").open(\"r\") as f:\n    content = f.read()\n\n# Also good for async\nfrom panpath import AsyncPanPath\n\nasync def read_file():\n    async with AsyncPanPath(\"s3://bucket/file.txt\").open(\"r\") as f:\n        content = await f.read()\n</code></pre>"},{"location":"getting-started/concepts/#4-prefer-bulk-operations","title":"4. Prefer Bulk Operations","text":"<pre><code>from panpath import PanPath\n\n# Less efficient: Individual copies\nsrc_dir = PanPath(\"s3://bucket/data/\")\ndst_dir = PanPath(\"gs://other/data/\")\nfor item in src_dir.iterdir():\n    item.copy(dst_dir / item.name)\n\n# More efficient: Use copytree\nsrc_dir.copytree(dst_dir)\n</code></pre>"},{"location":"getting-started/concepts/#next-steps","title":"Next Steps","text":"<ul> <li>Local Paths Guide - Learn about local filesystem operations</li> <li>Cloud Storage Guide - Cloud-specific features</li> <li>Async Operations Guide - Deep dive into async</li> <li>API Reference - Complete API documentation</li> </ul>"},{"location":"getting-started/installation/","title":"Installation","text":""},{"location":"getting-started/installation/#requirements","title":"Requirements","text":"<p>PanPath requires Python 3.8 or higher.</p>"},{"location":"getting-started/installation/#core-installation","title":"Core Installation","text":"<p>Install the core library which includes support for local file operations:</p> <pre><code>pip install panpath\n</code></pre> <p>The core installation includes:</p> <ul> <li>\u2705 Local filesystem support (sync and async)</li> <li>\u2705 Path manipulation and operations</li> <li>\u2705 Type hints and type safety</li> <li>\u2705 Zero cloud dependencies</li> </ul>"},{"location":"getting-started/installation/#cloud-storage-support","title":"Cloud Storage Support","text":"<p>PanPath uses optional dependencies for cloud storage backends. Install only what you need:</p>"},{"location":"getting-started/installation/#amazon-s3","title":"Amazon S3","text":"SynchronousAsynchronous <pre><code>pip install panpath[s3]\n</code></pre> <p>Installs: <code>boto3&gt;=1.20.0</code></p> <pre><code>pip install panpath[async-s3]\n</code></pre> <p>Installs: <code>aioboto3&gt;=11.0.0</code>, <code>aiofiles&gt;=23.0.0</code></p>"},{"location":"getting-started/installation/#google-cloud-storage","title":"Google Cloud Storage","text":"SynchronousAsynchronous <pre><code>pip install panpath[gs]\n</code></pre> <p>Installs: <code>google-cloud-storage&gt;=2.0.0</code></p> <pre><code>pip install panpath[async-gs]\n</code></pre> <p>Installs: <code>gcloud-aio-storage&gt;=8.0.0</code>, <code>aiofiles&gt;=23.0.0</code></p>"},{"location":"getting-started/installation/#azure-blob-storage","title":"Azure Blob Storage","text":"SynchronousAsynchronous <pre><code>pip install panpath[azure]\n</code></pre> <p>Installs: <code>azure-storage-blob&gt;=12.0.0</code></p> <pre><code>pip install panpath[async-azure]\n</code></pre> <p>Installs: <code>azure-storage-blob[aio]&gt;=12.0.0</code>, <code>aiofiles&gt;=23.0.0</code></p>"},{"location":"getting-started/installation/#convenience-bundles","title":"Convenience Bundles","text":""},{"location":"getting-started/installation/#all-sync-backends","title":"All Sync Backends","text":"<p>Install all synchronous cloud storage backends:</p> <pre><code>pip install panpath[all-sync]\n</code></pre> <p>Includes: S3, Google Cloud Storage, and Azure Blob Storage (sync only)</p>"},{"location":"getting-started/installation/#all-async-backends","title":"All Async Backends","text":"<p>Install all asynchronous cloud storage backends:</p> <pre><code>pip install panpath[all-async]\n</code></pre> <p>Includes: S3, Google Cloud Storage, and Azure Blob Storage (async only)</p>"},{"location":"getting-started/installation/#everything","title":"Everything","text":"<p>Install all backends (both sync and async):</p> <pre><code>pip install panpath[all]\n</code></pre> <p>Includes: All sync and async backends for all cloud providers</p>"},{"location":"getting-started/installation/#development-installation","title":"Development Installation","text":"<p>To contribute to PanPath or run tests:</p> <pre><code># Clone the repository\ngit clone https://github.com/pwwang/panpath.git\ncd panpath\n\n# Install in development mode with all dependencies\npip install -e .[all,dev]\n</code></pre> <p>The <code>dev</code> extra includes:</p> <ul> <li><code>pytest&gt;=7.0.0</code> - Testing framework</li> <li><code>pytest-asyncio&gt;=0.21.0</code> - Async test support</li> <li><code>pytest-cov&gt;=4.0.0</code> - Coverage reporting</li> <li><code>mypy&gt;=1.0.0</code> - Type checking</li> <li><code>black&gt;=23.0.0</code> - Code formatting</li> <li><code>ruff&gt;=0.1.0</code> - Linting</li> <li><code>moto[s3]&gt;=4.0.0</code> - AWS mocking for tests</li> </ul>"},{"location":"getting-started/installation/#verifying-installation","title":"Verifying Installation","text":"<p>After installation, verify that PanPath is working:</p> <pre><code>from panpath import PanPath\n\n# Test local paths\nlocal = PanPath(\"/tmp/test.txt\")\nprint(f\"Local path created: {local}\")\n\n# Test cloud paths (if installed)\ntry:\n    s3 = PanPath(\"s3://bucket/key\")\n    print(f\"S3 path created: {s3}\")\nexcept ImportError as e:\n    print(f\"S3 not available: {e}\")\n</code></pre>"},{"location":"getting-started/installation/#troubleshooting","title":"Troubleshooting","text":""},{"location":"getting-started/installation/#import-errors","title":"Import Errors","text":"<p>If you see <code>ImportError</code> when trying to use cloud paths:</p> <pre><code>from panpath import PanPath\n\npath = PanPath(\"s3://bucket/key\")  # ImportError!\n</code></pre> <p>Solution: Install the appropriate cloud backend:</p> <pre><code>pip install panpath[s3]\n</code></pre>"},{"location":"getting-started/installation/#dependency-conflicts","title":"Dependency Conflicts","text":"<p>If you encounter dependency conflicts:</p> <ol> <li> <p>Use a virtual environment:    <pre><code>python -m venv venv\nsource venv/bin/activate  # On Windows: venv\\Scripts\\activate\npip install panpath[all]\n</code></pre></p> </li> <li> <p>Update pip:    <pre><code>pip install --upgrade pip\n</code></pre></p> </li> <li> <p>Check installed packages:    <pre><code>pip list | grep -E \"(boto3|google-cloud-storage|azure-storage-blob|aiofiles)\"\n</code></pre></p> </li> </ol>"},{"location":"getting-started/installation/#version-requirements","title":"Version Requirements","text":"<p>Ensure you're using a supported Python version:</p> <pre><code>python --version  # Should be 3.8 or higher\n</code></pre>"},{"location":"getting-started/installation/#next-steps","title":"Next Steps","text":"<ul> <li>Quick Start Guide - Learn the basics with hands-on examples</li> <li>Basic Concepts - Understand PanPath's architecture</li> <li>User Guide - Dive into detailed feature documentation</li> </ul>"},{"location":"getting-started/quick-start/","title":"Quick Start","text":"<p>This guide will get you up and running with PanPath in minutes.</p>"},{"location":"getting-started/quick-start/#basic-usage","title":"Basic Usage","text":""},{"location":"getting-started/quick-start/#local-files","title":"Local Files","text":"<p>PanPath works just like <code>pathlib.Path</code> for local files:</p> <pre><code>from panpath import PanPath\n\n# Create a path\npath = PanPath(\"/tmp/example.txt\")\n\n# Write content\npath.write_text(\"Hello, PanPath!\")\n\n# Read content\ncontent = path.read_text()\nprint(content)  # Hello, PanPath!\n\n# Path operations\nparent = path.parent\nsibling = parent / \"another.txt\"\nprint(parent)   # /tmp\nprint(sibling)  # /tmp/another.txt\n</code></pre>"},{"location":"getting-started/quick-start/#cloud-storage","title":"Cloud Storage","text":"<p>The same API works for cloud storage:</p> Amazon S3Google Cloud StorageAzure Blob Storage <pre><code>from panpath import PanPath\n\n# Create S3 path\ns3_path = PanPath(\"s3://my-bucket/data/file.txt\")\n\n# Write to S3\ns3_path.write_text(\"Upload to S3\")\n\n# Read from S3\ncontent = s3_path.read_text()\n\n# List directory\ns3_dir = PanPath(\"s3://my-bucket/data/\")\nfor item in s3_dir.iterdir():\n    print(item)\n</code></pre> <pre><code>from panpath import PanPath\n\n# Create GCS path\ngs_path = PanPath(\"gs://my-bucket/data/file.txt\")\n\n# Write to GCS\ngs_path.write_text(\"Upload to GCS\")\n\n# Read from GCS\ncontent = gs_path.read_text()\n\n# Check if exists\nif gs_path.exists():\n    print(\"File exists!\")\n</code></pre> <pre><code>from panpath import PanPath\n\n# Create Azure path (both schemes work)\nazure_path = PanPath(\"az://my-container/data/file.txt\")\n# or\nazure_path = PanPath(\"azure://my-container/data/file.txt\")\n\n# Write to Azure\nazure_path.write_text(\"Upload to Azure\")\n\n# Read from Azure\ncontent = azure_path.read_text()\n\n# Get file info\nstats = azure_path.stat()\nprint(f\"Size: {stats.st_size} bytes\")\n</code></pre>"},{"location":"getting-started/quick-start/#async-operations","title":"Async Operations","text":"<p>For better performance with I/O operations, use async mode:</p> Using mode parameterUsing AsyncPanPathAsync Context Manager <pre><code>import asyncio\nfrom panpath import PanPath\n\nasync def main():\n    # Create async path with mode parameter\n    path = PanPath(\"s3://bucket/file.txt\", mode=\"async\")\n\n    # Use async operations\n    await path.write_text(\"Async upload\")\n    content = await path.read_text()\n    print(content)\n\nasyncio.run(main())\n</code></pre> <pre><code>import asyncio\nfrom panpath import AsyncPanPath\n\nasync def main():\n    # AsyncPanPath is always async\n    path = AsyncPanPath(\"s3://bucket/file.txt\")\n\n    # Use async operations\n    await path.write_text(\"Async upload\")\n    content = await path.read_text()\n    print(content)\n\nasyncio.run(main())\n</code></pre> <pre><code>import asyncio\nfrom panpath import AsyncPanPath\n\nasync def main():\n    path = AsyncPanPath(\"gs://bucket/file.txt\")\n\n    # Use async context manager\n    async with path.open(\"w\") as f:\n        await f.write(\"Line 1\\n\")\n        await f.write(\"Line 2\\n\")\n\n    # Read back\n    async with path.open(\"r\") as f:\n        content = await f.read()\n        print(content)\n\nasyncio.run(main())\n</code></pre>"},{"location":"getting-started/quick-start/#common-operations","title":"Common Operations","text":""},{"location":"getting-started/quick-start/#reading-and-writing","title":"Reading and Writing","text":"<pre><code>from panpath import PanPath\n\npath = PanPath(\"s3://bucket/data.txt\")\n\n# Text files\npath.write_text(\"Hello World\")\ntext = path.read_text()\n\n# Binary files\npath.write_bytes(b\"\\x00\\x01\\x02\")\ndata = path.read_bytes()\n\n# Using open()\nwith path.open(\"w\") as f:\n    f.write(\"Line 1\\n\")\n    f.write(\"Line 2\\n\")\n\nwith path.open(\"r\") as f:\n    for line in f:\n        print(line.strip())\n</code></pre>"},{"location":"getting-started/quick-start/#path-manipulation","title":"Path Manipulation","text":"<pre><code>from panpath import PanPath\n\npath = PanPath(\"s3://bucket/data/file.txt\")\n\n# Get components\nprint(path.name)        # file.txt\nprint(path.stem)        # file\nprint(path.suffix)      # .txt\nprint(path.parent)      # s3://bucket/data\n\n# Join paths\nnew_path = path.parent / \"other.txt\"\nprint(new_path)  # s3://bucket/data/other.txt\n\n# Change components\nrenamed = path.with_name(\"newfile.txt\")\nprint(renamed)  # s3://bucket/data/newfile.txt\n\ndifferent_ext = path.with_suffix(\".csv\")\nprint(different_ext)  # s3://bucket/data/file.csv\n</code></pre>"},{"location":"getting-started/quick-start/#checking-path-properties","title":"Checking Path Properties","text":"<pre><code>from panpath import PanPath\n\npath = PanPath(\"gs://bucket/file.txt\")\n\n# Check existence\nif path.exists():\n    print(\"File exists\")\n\n# Check type\nif path.is_file():\n    print(\"It's a file\")\nelif path.is_dir():\n    print(\"It's a directory\")\n\n# Get metadata\nstat = path.stat()\nprint(f\"Size: {stat.st_size} bytes\")\nprint(f\"Modified: {stat.st_mtime}\")\n</code></pre>"},{"location":"getting-started/quick-start/#directory-operations","title":"Directory Operations","text":"<pre><code>from panpath import PanPath\n\ndirectory = PanPath(\"s3://bucket/data/\")\n\n# List contents\nfor item in directory.iterdir():\n    print(item)\n\n# Find files matching pattern\nfor txt_file in directory.glob(\"*.txt\"):\n    print(txt_file)\n\n# Recursive search\nfor py_file in directory.rglob(\"*.py\"):\n    print(py_file)\n\n# Create directory\nnew_dir = PanPath(\"s3://bucket/newdir/\")\nnew_dir.mkdir(parents=True, exist_ok=True)\n</code></pre>"},{"location":"getting-started/quick-start/#bulk-operations","title":"Bulk Operations","text":"<p>Copy and move files efficiently:</p> <pre><code>from panpath import PanPath\n\n# Copy a file\nsrc = PanPath(\"s3://bucket/source.txt\")\nsrc.copy(\"s3://bucket/backup/source.txt\")\n\n# Copy a directory tree\nsrc_dir = PanPath(\"s3://bucket/data/\")\nsrc_dir.copytree(\"gs://other-bucket/data/\")\n\n# Remove a directory tree\ntemp_dir = PanPath(\"s3://bucket/temp/\")\ntemp_dir.rmtree()\n\n# Rename/move\nold_path = PanPath(\"s3://bucket/old.txt\")\nold_path.rename(\"s3://bucket/new.txt\")\n</code></pre>"},{"location":"getting-started/quick-start/#cross-storage-transfers","title":"Cross-Storage Transfers","text":"<p>Move data between different storage backends:</p> <pre><code>from panpath import PanPath\n\n# S3 to local\ns3_file = PanPath(\"s3://bucket/data.csv\")\ns3_file.copy(\"/tmp/data.csv\")\n\n# Local to GCS\nlocal_file = PanPath(\"/tmp/data.csv\")\nlocal_file.copy(\"gs://bucket/data.csv\")\n\n# S3 to Azure\ns3_file = PanPath(\"s3://bucket/file.txt\")\ns3_file.copy(\"az://container/file.txt\")\n\n# Copy entire directory from cloud to local\ncloud_dataset = PanPath(\"gs://data-lake/dataset/\")\ncloud_dataset.copytree(\"/local/dataset/\")\n</code></pre>"},{"location":"getting-started/quick-start/#configuration","title":"Configuration","text":""},{"location":"getting-started/quick-start/#environment-variables","title":"Environment Variables","text":"<p>Configure cloud credentials using environment variables:</p> AWS S3Google CloudAzure <pre><code>export AWS_ACCESS_KEY_ID=your_access_key\nexport AWS_SECRET_ACCESS_KEY=your_secret_key\nexport AWS_DEFAULT_REGION=us-east-1\n</code></pre> <pre><code>export GOOGLE_APPLICATION_CREDENTIALS=/path/to/credentials.json\n</code></pre> <pre><code>export AZURE_STORAGE_CONNECTION_STRING=your_connection_string\n# or\nexport AZURE_STORAGE_ACCOUNT_NAME=your_account\nexport AZURE_STORAGE_ACCOUNT_KEY=your_key\n</code></pre>"},{"location":"getting-started/quick-start/#custom-client-configuration","title":"Custom Client Configuration","text":"<p>For advanced use cases, you can configure clients:</p> <pre><code>from panpath import PanPath\nfrom panpath.clients import get_s3_client\n\n# Get or create client with custom config\nclient = get_s3_client(\n    aws_access_key_id=\"your_key\",\n    aws_secret_access_key=\"your_secret\",\n    region_name=\"us-west-2\"\n)\n\n# Use the path normally\npath = PanPath(\"s3://bucket/file.txt\")\n</code></pre>"},{"location":"getting-started/quick-start/#next-steps","title":"Next Steps","text":"<p>Now that you know the basics:</p> <ul> <li>Basic Concepts - Learn about PanPath's architecture</li> <li>User Guide - Explore all features in detail</li> <li>Cloud Providers - Provider-specific documentation</li> <li>API Reference - Complete API documentation</li> </ul>"},{"location":"guide/async-operations/","title":"Async Operations","text":"<p>Deep dive into asynchronous operations with PanPath.</p>"},{"location":"guide/async-operations/#why-async","title":"Why Async?","text":"<p>Async operations provide:</p> <ul> <li>Better Concurrency - Handle multiple I/O operations simultaneously</li> <li>Resource Efficiency - Non-blocking I/O uses less threads</li> <li>Performance - Faster for I/O-bound workloads</li> <li>Scalability - Handle more connections with fewer resources</li> </ul>"},{"location":"guide/async-operations/#choosing-sync-or-async","title":"Choosing Sync or Async","text":"<p>Use sync when: - Writing simple scripts - Operations are infrequent - Working with synchronous frameworks - Simplicity is more important than performance</p> <p>Use async when: - Building async applications (FastAPI, aiohttp) - Performing many I/O operations - Need high concurrency - Want better resource utilization</p>"},{"location":"guide/async-operations/#basic-async-usage","title":"Basic Async Usage","text":"<pre><code>import asyncio\nfrom panpath import AsyncPanPath\n\nasync def main():\n    path = AsyncPanPath(\"s3://bucket/file.txt\")\n\n    # Async operations\n    await path.write_text(\"Content\")\n    content = await path.read_text()\n    exists = await path.exists()\n\nasyncio.run(main())\n</code></pre>"},{"location":"guide/async-operations/#parallel-operations","title":"Parallel Operations","text":"<pre><code>import asyncio\nfrom panpath import AsyncPanPath\n\nasync def download_all(uris: list[str]):\n    paths = [AsyncPanPath(uri) for uri in uris]\n\n    # Download concurrently\n    contents = await asyncio.gather(*[p.read_text() for p in paths])\n\n    return contents\n\nuris = [\n    \"s3://bucket/file1.txt\",\n    \"s3://bucket/file2.txt\",\n    \"s3://bucket/file3.txt\",\n]\n\nasyncio.run(download_all(uris))\n</code></pre>"},{"location":"guide/async-operations/#see-also","title":"See Also","text":"<ul> <li>Quick Start - Async examples</li> <li>Performance Guide - Optimization tips</li> <li>API Reference - AsyncPanPath API</li> </ul>"},{"location":"guide/bulk-operations/","title":"Bulk Operations","text":"<p>PanPath provides efficient bulk operations for working with directories and multiple files.</p>"},{"location":"guide/bulk-operations/#overview","title":"Overview","text":"<p>Bulk operations are optimized for performance and work seamlessly across different storage backends:</p> <ul> <li><code>rmtree()</code> - Remove directory and all contents</li> <li><code>copy(src, dst)</code> - Copy a single file</li> <li><code>copytree(src, dst)</code> - Copy entire directory tree</li> <li><code>rename(src, dst)</code> - Move/rename files (enhanced for cross-storage)</li> </ul> <p>All operations support:</p> <p>\u2705 Cross-storage transfers (S3 \u2194 GCS \u2194 Azure \u2194 Local) \u2705 Synchronous and asynchronous modes \u2705 Recursive directory operations \u2705 Progress tracking (where applicable)</p>"},{"location":"guide/bulk-operations/#removing-directory-trees","title":"Removing Directory Trees","text":""},{"location":"guide/bulk-operations/#basic-usage","title":"Basic Usage","text":"<p>Remove a directory and all its contents:</p> SyncAsync <pre><code>from panpath import PanPath\n\n# Remove S3 directory\ns3_dir = PanPath(\"s3://bucket/logs/\")\ns3_dir.rmtree()\n\n# Remove local directory\nlocal_dir = PanPath(\"/tmp/cache/\")\nlocal_dir.rmtree()\n\n# Remove GCS directory\ngs_dir = PanPath(\"gs://bucket/temp/\")\ngs_dir.rmtree()\n</code></pre> <pre><code>from panpath import AsyncPanPath\nimport asyncio\n\nasync def cleanup():\n    # Remove Azure directory\n    azure_dir = AsyncPanPath(\"az://container/temp/\")\n    await azure_dir.rmtree()\n\n    # Remove S3 directory\n    s3_dir = AsyncPanPath(\"s3://bucket/old-data/\")\n    await s3_dir.rmtree()\n\nasyncio.run(cleanup())\n</code></pre>"},{"location":"guide/bulk-operations/#safety-options","title":"Safety Options","text":"<pre><code>from panpath import PanPath\n\ndirectory = PanPath(\"s3://bucket/data/\")\n\n# Check before deleting\nif directory.exists() and directory.is_dir():\n    file_count = len(list(directory.rglob(\"*\")))\n    print(f\"About to delete {file_count} files\")\n\n    if input(\"Continue? (y/n): \").lower() == \"y\":\n        directory.rmtree()\n</code></pre>"},{"location":"guide/bulk-operations/#error-handling","title":"Error Handling","text":"<pre><code>from panpath import PanPath\nfrom panpath.exceptions import PathNotFoundError, PermissionError\n\ndirectory = PanPath(\"s3://bucket/data/\")\n\ntry:\n    directory.rmtree()\nexcept PathNotFoundError:\n    print(\"Directory doesn't exist\")\nexcept PermissionError:\n    print(\"Access denied\")\n</code></pre>"},{"location":"guide/bulk-operations/#copying-files","title":"Copying Files","text":""},{"location":"guide/bulk-operations/#single-file-copy","title":"Single File Copy","text":"<p>Copy a file to a new location:</p> Same StorageCross-StorageAsync <pre><code>from panpath import PanPath\n\n# S3 to S3 (server-side copy - fast!)\nsrc = PanPath(\"s3://bucket/data.csv\")\nsrc.copy(\"s3://bucket/backup/data.csv\")\n\n# GCS to GCS\nsrc = PanPath(\"gs://bucket/file.txt\")\nsrc.copy(\"gs://bucket/archive/file.txt\")\n</code></pre> <pre><code>from panpath import PanPath\n\n# S3 to GCS\ns3_file = PanPath(\"s3://bucket/data.json\")\ns3_file.copy(\"gs://other-bucket/data.json\")\n\n# Cloud to local\ncloud = PanPath(\"az://container/report.pdf\")\ncloud.copy(\"/tmp/report.pdf\")\n\n# Local to cloud\nlocal = PanPath(\"/data/upload.txt\")\nlocal.copy(\"s3://bucket/upload.txt\")\n</code></pre> <pre><code>from panpath import AsyncPanPath\nimport asyncio\n\nasync def copy_files():\n    # Async copy\n    src = AsyncPanPath(\"s3://bucket/file.txt\")\n    await src.copy(\"gs://other/file.txt\")\n\n    # Multiple concurrent copies\n    files = [\n        (\"s3://bucket/a.txt\", \"gs://backup/a.txt\"),\n        (\"s3://bucket/b.txt\", \"gs://backup/b.txt\"),\n        (\"s3://bucket/c.txt\", \"gs://backup/c.txt\"),\n    ]\n\n    await asyncio.gather(*[\n        AsyncPanPath(src).copy(dst)\n        for src, dst in files\n    ])\n\nasyncio.run(copy_files())\n</code></pre>"},{"location":"guide/bulk-operations/#copy-options","title":"Copy Options","text":"<pre><code>from panpath import PanPath\n\nsrc = PanPath(\"s3://bucket/file.txt\")\n\n# Basic copy\nsrc.copy(\"s3://bucket/backup/file.txt\")\n\n# Overwrite if exists\nsrc.copy(\"s3://bucket/backup/file.txt\", overwrite=True)\n\n# Copy to PanPath object\ndst = PanPath(\"gs://other/file.txt\")\nsrc.copy(dst)\n</code></pre>"},{"location":"guide/bulk-operations/#copying-directory-trees","title":"Copying Directory Trees","text":""},{"location":"guide/bulk-operations/#basic-usage_1","title":"Basic Usage","text":"<p>Copy an entire directory structure recursively:</p> DownloadUploadCloud-to-Cloud <pre><code>from panpath import PanPath\n\n# Download from S3 to local\ns3_dir = PanPath(\"s3://data-lake/dataset/\")\ns3_dir.copytree(\"/tmp/dataset/\")\n\n# Download from GCS\ngs_dir = PanPath(\"gs://bucket/models/\")\ngs_dir.copytree(\"/local/models/\")\n</code></pre> <pre><code>from panpath import PanPath\n\n# Upload from local to S3\nlocal_dir = PanPath(\"/home/user/project/\")\nlocal_dir.copytree(\"s3://backups/project/\")\n\n# Upload to Azure\nlocal_data = PanPath(\"/data/\")\nlocal_data.copytree(\"az://container/data/\")\n</code></pre> <pre><code>from panpath import PanPath\n\n# Mirror between cloud providers\ns3_dir = PanPath(\"s3://source/data/\")\ns3_dir.copytree(\"gs://target/data/\")\n\n# Azure to S3\nazure_dir = PanPath(\"az://container/files/\")\nazure_dir.copytree(\"s3://bucket/files/\")\n</code></pre>"},{"location":"guide/bulk-operations/#async-copytree","title":"Async Copytree","text":"<pre><code>from panpath import AsyncPanPath\nimport asyncio\n\nasync def backup_datasets():\n    # Async directory copy\n    src = AsyncPanPath(\"s3://production/data/\")\n    await src.copytree(\"s3://backup/data/\")\n\n    # Multiple concurrent copytree operations\n    tasks = [\n        AsyncPanPath(\"s3://bucket/logs/\").copytree(\"/backup/logs/\"),\n        AsyncPanPath(\"s3://bucket/data/\").copytree(\"/backup/data/\"),\n        AsyncPanPath(\"s3://bucket/config/\").copytree(\"/backup/config/\"),\n    ]\n    await asyncio.gather(*tasks)\n\nasyncio.run(backup_datasets())\n</code></pre>"},{"location":"guide/bulk-operations/#advanced-options","title":"Advanced Options","text":"<pre><code>from panpath import PanPath\n\nsrc_dir = PanPath(\"s3://bucket/data/\")\ndst_dir = PanPath(\"gs://other/data/\")\n\n# Basic copytree\nsrc_dir.copytree(dst_dir)\n\n# Skip existing files\nsrc_dir.copytree(dst_dir, exist_ok=True)\n\n# Custom filtering (if supported)\nsrc_dir.copytree(\n    dst_dir,\n    ignore_patterns=[\"*.tmp\", \"*.log\"]\n)\n</code></pre>"},{"location":"guide/bulk-operations/#moving-and-renaming","title":"Moving and Renaming","text":""},{"location":"guide/bulk-operations/#enhanced-cross-storage-rename","title":"Enhanced Cross-Storage Rename","text":"<p>The <code>rename()</code> method now supports cross-storage operations by copying to the destination and deleting the source:</p> Same StorageCross-StorageAsync <pre><code>from panpath import PanPath\n\n# S3 to S3 (efficient server-side rename)\nold = PanPath(\"s3://bucket/old-name.txt\")\nold.rename(\"s3://bucket/new-name.txt\")\n\n# Move to different folder\nfile = PanPath(\"s3://bucket/temp/file.txt\")\nfile.rename(\"s3://bucket/archive/file.txt\")\n</code></pre> <pre><code>from panpath import PanPath\n\n# S3 to GCS (copies then deletes)\ns3_file = PanPath(\"s3://old-bucket/file.txt\")\ns3_file.rename(\"gs://new-bucket/file.txt\")\n\n# Cloud to local\ncloud = PanPath(\"az://container/temp.log\")\ncloud.rename(\"/var/log/temp.log\")\n\n# Between any backends\nsrc = PanPath(\"gs://bucket/data.csv\")\nsrc.rename(\"s3://other/data.csv\")\n</code></pre> <pre><code>from panpath import AsyncPanPath\nimport asyncio\n\nasync def move_files():\n    # Async rename/move\n    old = AsyncPanPath(\"s3://bucket/old.txt\")\n    await old.rename(\"gs://other/new.txt\")\n\n    # Move multiple files concurrently\n    files = [\n        (\"s3://bucket/a.txt\", \"gs://backup/a.txt\"),\n        (\"s3://bucket/b.txt\", \"gs://backup/b.txt\"),\n    ]\n\n    await asyncio.gather(*[\n        AsyncPanPath(src).rename(dst)\n        for src, dst in files\n    ])\n\nasyncio.run(move_files())\n</code></pre>"},{"location":"guide/bulk-operations/#return-value","title":"Return Value","text":"<p><code>rename()</code> returns the new path:</p> <pre><code>from panpath import PanPath\n\nold_path = PanPath(\"s3://bucket/old.txt\")\nnew_path = old_path.rename(\"s3://bucket/new.txt\")\n\nprint(new_path)  # s3://bucket/new.txt\nprint(new_path.exists())  # True\nprint(old_path.exists())  # False\n</code></pre>"},{"location":"guide/bulk-operations/#performance-considerations","title":"Performance Considerations","text":""},{"location":"guide/bulk-operations/#server-side-operations","title":"Server-Side Operations","text":"<p>When source and destination are on the same storage backend, operations use server-side APIs:</p> <pre><code>from panpath import PanPath\n\n# Fast: S3 server-side copy\ns3_src = PanPath(\"s3://bucket/large-file.bin\")\ns3_src.copy(\"s3://bucket/backup/large-file.bin\")  # No download/upload!\n\n# Fast: GCS server-side copy\ngs_src = PanPath(\"gs://bucket/data.tar.gz\")\ngs_src.copy(\"gs://bucket/archive/data.tar.gz\")  # No download/upload!\n</code></pre>"},{"location":"guide/bulk-operations/#cross-storage-transfer","title":"Cross-Storage Transfer","text":"<p>Cross-storage operations require download and upload:</p> <pre><code>from panpath import PanPath\n\n# Slower: Downloads from S3, uploads to GCS\ns3_file = PanPath(\"s3://bucket/large-file.bin\")\ns3_file.copy(\"gs://other/large-file.bin\")  # Downloads then uploads\n</code></pre>"},{"location":"guide/bulk-operations/#parallel-async-operations","title":"Parallel Async Operations","text":"<p>Use async for concurrent operations:</p> <pre><code>from panpath import AsyncPanPath\nimport asyncio\n\nasync def parallel_copy():\n    files = [f\"s3://bucket/file{i}.txt\" for i in range(100)]\n\n    # Copy all files concurrently\n    tasks = [\n        AsyncPanPath(src).copy(f\"gs://backup/file{i}.txt\")\n        for i, src in enumerate(files)\n    ]\n\n    await asyncio.gather(*tasks)\n    print(\"Copied 100 files concurrently!\")\n\nasyncio.run(parallel_copy())\n</code></pre>"},{"location":"guide/bulk-operations/#chunked-operations","title":"Chunked Operations","text":"<p>For very large directories, process in chunks:</p> <pre><code>from panpath import PanPath\nfrom itertools import islice\n\ndef chunked_copytree(src, dst, chunk_size=100):\n    \"\"\"Copy directory in chunks.\"\"\"\n    src_path = PanPath(src)\n    dst_path = PanPath(dst)\n\n    # Get all files\n    files = list(src_path.rglob(\"*\"))\n\n    # Process in chunks\n    for i in range(0, len(files), chunk_size):\n        chunk = files[i:i + chunk_size]\n        for file in chunk:\n            if file.is_file():\n                rel_path = file.relative_to(src_path)\n                file.copy(dst_path / rel_path)\n        print(f\"Processed {min(i + chunk_size, len(files))}/{len(files)} files\")\n\nchunked_copytree(\"s3://huge-bucket/data/\", \"/local/data/\")\n</code></pre>"},{"location":"guide/bulk-operations/#examples","title":"Examples","text":""},{"location":"guide/bulk-operations/#backup-script","title":"Backup Script","text":"<pre><code>from panpath import PanPath\nfrom datetime import datetime\n\ndef backup_to_cloud(local_dir: str, cloud_bucket: str):\n    \"\"\"Backup local directory to cloud with timestamp.\"\"\"\n    timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n\n    src = PanPath(local_dir)\n    dst = PanPath(f\"{cloud_bucket}/backup_{timestamp}/\")\n\n    print(f\"Backing up {src} to {dst}...\")\n    src.copytree(dst)\n    print(\"Backup complete!\")\n\n# Usage\nbackup_to_cloud(\"/important/data/\", \"s3://backups/\")\n</code></pre>"},{"location":"guide/bulk-operations/#cleanup-old-files","title":"Cleanup Old Files","text":"<pre><code>from panpath import PanPath\nfrom datetime import datetime, timedelta\n\ndef cleanup_old_files(directory: str, days: int = 30):\n    \"\"\"Remove files older than specified days.\"\"\"\n    cutoff = datetime.now().timestamp() - (days * 86400)\n    dir_path = PanPath(directory)\n\n    for file in dir_path.rglob(\"*\"):\n        if file.is_file():\n            stat = file.stat()\n            if stat.st_mtime &lt; cutoff:\n                print(f\"Removing old file: {file}\")\n                file.unlink()\n\n# Usage\ncleanup_old_files(\"s3://bucket/logs/\", days=90)\n</code></pre>"},{"location":"guide/bulk-operations/#mirror-directories","title":"Mirror Directories","text":"<pre><code>from panpath import PanPath\n\ndef mirror_directories(src: str, dst: str, clean_dst: bool = False):\n    \"\"\"Mirror source directory to destination.\"\"\"\n    src_path = PanPath(src)\n    dst_path = PanPath(dst)\n\n    # Optionally clean destination\n    if clean_dst and dst_path.exists():\n        print(f\"Cleaning {dst_path}...\")\n        dst_path.rmtree()\n\n    # Copy directory tree\n    print(f\"Mirroring {src_path} to {dst_path}...\")\n    src_path.copytree(dst_path)\n    print(\"Mirror complete!\")\n\n# Usage\nmirror_directories(\"s3://production/data/\", \"s3://backup/data/\", clean_dst=True)\n</code></pre>"},{"location":"guide/bulk-operations/#async-batch-operations","title":"Async Batch Operations","text":"<pre><code>from panpath import AsyncPanPath\nimport asyncio\n\nasync def batch_process(files: list[str], operation: str):\n    \"\"\"Process multiple files concurrently.\"\"\"\n    paths = [AsyncPanPath(f) for f in files]\n\n    if operation == \"delete\":\n        await asyncio.gather(*[p.unlink() for p in paths])\n    elif operation == \"backup\":\n        await asyncio.gather(*[\n            p.copy(f\"s3://backup/{p.name}\")\n            for p in paths\n        ])\n\n    print(f\"Processed {len(files)} files\")\n\n# Usage\nfiles = [f\"s3://bucket/temp/file{i}.txt\" for i in range(1000)]\nasyncio.run(batch_process(files, \"delete\"))\n</code></pre>"},{"location":"guide/bulk-operations/#best-practices","title":"Best Practices","text":""},{"location":"guide/bulk-operations/#1-check-before-deleting","title":"1. Check Before Deleting","text":"<pre><code>from panpath import PanPath\n\ndef safe_rmtree(path: str):\n    \"\"\"Safely remove directory with confirmation.\"\"\"\n    dir_path = PanPath(path)\n\n    if not dir_path.exists():\n        print(f\"{path} doesn't exist\")\n        return\n\n    # Count files\n    files = list(dir_path.rglob(\"*\"))\n    file_count = len([f for f in files if f.is_file()])\n\n    # Confirm\n    print(f\"About to delete {file_count} files from {path}\")\n    if input(\"Continue? (yes/no): \") == \"yes\":\n        dir_path.rmtree()\n        print(\"Deleted!\")\n    else:\n        print(\"Cancelled\")\n</code></pre>"},{"location":"guide/bulk-operations/#2-use-async-for-large-batches","title":"2. Use Async for Large Batches","text":"<pre><code># Slow: Sequential\nfrom panpath import PanPath\nfor i in range(1000):\n    PanPath(f\"s3://bucket/file{i}.txt\").copy(f\"gs://other/file{i}.txt\")\n\n# Fast: Concurrent\nfrom panpath import AsyncPanPath\nimport asyncio\n\nasync def fast_copy():\n    await asyncio.gather(*[\n        AsyncPanPath(f\"s3://bucket/file{i}.txt\").copy(f\"gs://other/file{i}.txt\")\n        for i in range(1000)\n    ])\n\nasyncio.run(fast_copy())\n</code></pre>"},{"location":"guide/bulk-operations/#3-handle-errors-gracefully","title":"3. Handle Errors Gracefully","text":"<pre><code>from panpath import PanPath\nfrom panpath.exceptions import PanPathException\n\ndef robust_copytree(src: str, dst: str):\n    \"\"\"Copy directory with error handling.\"\"\"\n    src_path = PanPath(src)\n    dst_path = PanPath(dst)\n\n    try:\n        src_path.copytree(dst_path)\n        print(\"Copy successful!\")\n    except PanPathException as e:\n        print(f\"Error during copy: {e}\")\n        # Cleanup partial copy\n        if dst_path.exists():\n            print(\"Cleaning up partial copy...\")\n            dst_path.rmtree()\n        raise\n</code></pre>"},{"location":"guide/bulk-operations/#next-steps","title":"Next Steps","text":"<ul> <li>Cross-Storage Transfers - More on cross-backend operations</li> <li>Async Operations - Deep dive into async patterns</li> <li>Performance Guide - Optimization tips</li> <li>API Reference - Complete API documentation</li> </ul>"},{"location":"guide/cloud-storage/","title":"Cloud Storage","text":"<p>Working with cloud storage providers using PanPath.</p>"},{"location":"guide/cloud-storage/#supported-providers","title":"Supported Providers","text":"<p>PanPath supports three major cloud storage providers:</p> <ul> <li>Amazon S3 - <code>s3://bucket/key</code></li> <li>Google Cloud Storage - <code>gs://bucket/path</code></li> <li>Azure Blob Storage - <code>az://container/blob</code> or <code>azure://container/blob</code></li> </ul>"},{"location":"guide/cloud-storage/#basic-usage","title":"Basic Usage","text":"<pre><code>from panpath import PanPath\n\n# S3\ns3 = PanPath(\"s3://my-bucket/data/file.txt\")\ns3.write_text(\"Content\")\n\n# Google Cloud Storage\ngs = PanPath(\"gs://my-bucket/data/file.txt\")\ngs.write_text(\"Content\")\n\n# Azure Blob Storage\nazure = PanPath(\"az://my-container/data/file.txt\")\nazure.write_text(\"Content\")\n</code></pre>"},{"location":"guide/cloud-storage/#cloud-specific-properties","title":"Cloud-Specific Properties","text":"<pre><code>path = PanPath(\"s3://my-bucket/folder/file.txt\")\n\n# Cloud prefix (bucket/container with scheme)\nprint(path.cloud_prefix)  # s3://my-bucket\n\n# Key (path within bucket)\nprint(path.key)  # folder/file.txt\n\n# Bucket/container name\nprint(path.bucket)  # my-bucket\n</code></pre>"},{"location":"guide/cloud-storage/#see-also","title":"See Also","text":"<ul> <li>Amazon S3 - S3-specific documentation</li> <li>Google Cloud Storage - GCS-specific documentation</li> <li>Azure Blob Storage - Azure-specific documentation</li> <li>Bulk Operations - Efficient cloud operations</li> </ul>"},{"location":"guide/cross-storage/","title":"Cross-Storage Transfers","text":"<p>Transfer files between different storage backends seamlessly.</p>"},{"location":"guide/cross-storage/#overview","title":"Overview","text":"<p>PanPath supports copying and moving files between: - Local \u2194 Cloud - Cloud \u2194 Cloud (different providers) - Cloud \u2194 Cloud (same provider)</p>"},{"location":"guide/cross-storage/#local-to-cloud","title":"Local to Cloud","text":"<pre><code>from panpath import PanPath\n\n# Upload to S3\nlocal = PanPath(\"/data/file.txt\")\nlocal.copy(\"s3://bucket/file.txt\")\n\n# Upload to GCS\nlocal.copy(\"gs://bucket/file.txt\")\n\n# Upload directory\nlocal_dir = PanPath(\"/data/\")\nlocal_dir.copytree(\"s3://bucket/data/\")\n</code></pre>"},{"location":"guide/cross-storage/#cloud-to-local","title":"Cloud to Local","text":"<pre><code>from panpath import PanPath\n\n# Download from S3\ns3 = PanPath(\"s3://bucket/file.txt\")\ns3.copy(\"/tmp/file.txt\")\n\n# Download directory\ns3_dir = PanPath(\"s3://bucket/data/\")\ns3_dir.copytree(\"/tmp/data/\")\n</code></pre>"},{"location":"guide/cross-storage/#cloud-to-cloud","title":"Cloud to Cloud","text":"<pre><code>from panpath import PanPath\n\n# S3 to GCS\ns3 = PanPath(\"s3://bucket/file.txt\")\ns3.copy(\"gs://other-bucket/file.txt\")\n\n# Azure to S3\nazure = PanPath(\"az://container/file.txt\")\nazure.copy(\"s3://bucket/file.txt\")\n</code></pre>"},{"location":"guide/cross-storage/#performance-considerations","title":"Performance Considerations","text":"<ul> <li>Same backend: Uses server-side copy (fast)</li> <li>Different backends: Downloads then uploads (slower)</li> <li>Use async: For better performance with multiple files</li> </ul>"},{"location":"guide/cross-storage/#see-also","title":"See Also","text":"<ul> <li>Bulk Operations - Efficient directory operations</li> <li>Quick Start - Basic examples</li> </ul>"},{"location":"guide/error-handling/","title":"Error Handling","text":"<p>Understanding and handling errors in PanPath.</p>"},{"location":"guide/error-handling/#common-exceptions","title":"Common Exceptions","text":"<pre><code>from panpath import PanPath\nfrom panpath.exceptions import (\n    PanPathException,\n    PathNotFoundError,\n    PermissionError,\n)\n\npath = PanPath(\"s3://bucket/nonexistent.txt\")\n\ntry:\n    content = path.read_text()\nexcept PathNotFoundError:\n    print(\"File not found\")\nexcept PermissionError:\n    print(\"Access denied\")\nexcept PanPathException as e:\n    print(f\"Other error: {e}\")\n</code></pre>"},{"location":"guide/error-handling/#provider-specific-errors","title":"Provider-Specific Errors","text":""},{"location":"guide/error-handling/#aws-s3","title":"AWS S3","text":"<pre><code>import botocore.exceptions\n\ntry:\n    path.read_text()\nexcept botocore.exceptions.NoCredentialsError:\n    print(\"AWS credentials not configured\")\nexcept botocore.exceptions.ClientError as e:\n    error_code = e.response['Error']['Code']\n    if error_code == '404':\n        print(\"Not found\")\n</code></pre>"},{"location":"guide/error-handling/#google-cloud-storage","title":"Google Cloud Storage","text":"<pre><code>from google.cloud import exceptions\n\ntry:\n    path.read_text()\nexcept exceptions.NotFound:\n    print(\"Not found\")\nexcept exceptions.Forbidden:\n    print(\"Access denied\")\n</code></pre>"},{"location":"guide/error-handling/#azure-blob-storage","title":"Azure Blob Storage","text":"<pre><code>from azure.core.exceptions import ResourceNotFoundError\n\ntry:\n    path.read_text()\nexcept ResourceNotFoundError:\n    print(\"Not found\")\n</code></pre>"},{"location":"guide/error-handling/#best-practices","title":"Best Practices","text":"<pre><code>from panpath import PanPath\n\ndef safe_read(uri: str) -&gt; str | None:\n    \"\"\"Safely read file, return None if not found.\"\"\"\n    try:\n        path = PanPath(uri)\n        return path.read_text()\n    except Exception as e:\n        print(f\"Error reading {uri}: {e}\")\n        return None\n</code></pre>"},{"location":"guide/local-paths/","title":"Local Paths","text":"<p>Working with local filesystem paths using PanPath.</p>"},{"location":"guide/local-paths/#overview","title":"Overview","text":"<p>PanPath provides a pathlib-compatible interface for local files, making it a drop-in replacement for <code>pathlib.Path</code>.</p>"},{"location":"guide/local-paths/#basic-usage","title":"Basic Usage","text":"<pre><code>from panpath import PanPath\n\n# Create a local path\npath = PanPath(\"/tmp/file.txt\")\n\n# Or use file:// URI\npath = PanPath(\"file:///tmp/file.txt\")\n\n# Works like pathlib.Path\npath.write_text(\"Hello, World!\")\ncontent = path.read_text()\nprint(content)  # Hello, World!\n</code></pre>"},{"location":"guide/local-paths/#compatibility-with-pathlib","title":"Compatibility with pathlib","text":"<pre><code>from pathlib import Path\nfrom panpath import PanPath\n\n# These work identically\npathlib_path = Path(\"/tmp/file.txt\")\npan_path = PanPath(\"/tmp/file.txt\")\n\n# Same operations\npathlib_path.write_text(\"content\")\npan_path.write_text(\"content\")\n\n# Same results\nassert pathlib_path.name == pan_path.name\nassert pathlib_path.suffix == pan_path.suffix\nassert pathlib_path.parent == PanPath(str(pathlib_path.parent))\n</code></pre>"},{"location":"guide/local-paths/#async-local-operations","title":"Async Local Operations","text":"<pre><code>import asyncio\nfrom panpath import AsyncPanPath\n\nasync def main():\n    path = AsyncPanPath(\"/tmp/file.txt\")\n\n    # Async write\n    await path.write_text(\"Async content\")\n\n    # Async read\n    content = await path.read_text()\n    print(content)\n\n    # Async context manager\n    async with path.open(\"w\") as f:\n        await f.write(\"Line 1\\n\")\n        await f.write(\"Line 2\\n\")\n\nasyncio.run(main())\n</code></pre>"},{"location":"guide/local-paths/#see-also","title":"See Also","text":"<ul> <li>Path Operations - Comprehensive path manipulation guide</li> <li>Async Operations - Async patterns and best practices</li> <li>API Reference - Complete API documentation</li> </ul>"},{"location":"guide/path-operations/","title":"Path Operations","text":"<p>Comprehensive guide to path manipulation and querying.</p>"},{"location":"guide/path-operations/#path-components","title":"Path Components","text":"<pre><code>from panpath import PanPath\n\npath = PanPath(\"s3://bucket/dir/file.tar.gz\")\n\nprint(path.name)        # file.tar.gz\nprint(path.stem)        # file.tar\nprint(path.suffix)      # .gz\nprint(path.suffixes)    # ['.tar', '.gz']\nprint(path.parent)      # s3://bucket/dir\nprint(path.parts)       # ('s3://bucket', 'dir', 'file.tar.gz')\n</code></pre>"},{"location":"guide/path-operations/#joining-paths","title":"Joining Paths","text":"<pre><code>from panpath import PanPath\n\nbase = PanPath(\"s3://bucket/data\")\n\n# Using / operator\npath1 = base / \"subdir\" / \"file.txt\"\n\n# Using joinpath\npath2 = base.joinpath(\"subdir\", \"file.txt\")\n\nprint(path1)  # s3://bucket/data/subdir/file.txt\nprint(path2)  # s3://bucket/data/subdir/file.txt\n</code></pre>"},{"location":"guide/path-operations/#modifying-paths","title":"Modifying Paths","text":"<pre><code>from panpath import PanPath\n\npath = PanPath(\"s3://bucket/data/file.txt\")\n\n# Change filename\nnew = path.with_name(\"newfile.txt\")\n# s3://bucket/data/newfile.txt\n\n# Change stem\nnew = path.with_stem(\"document\")\n# s3://bucket/data/document.txt\n\n# Change suffix\nnew = path.with_suffix(\".csv\")\n# s3://bucket/data/file.csv\n</code></pre>"},{"location":"guide/path-operations/#pattern-matching","title":"Pattern Matching","text":"<pre><code>from panpath import PanPath\n\npath = PanPath(\"s3://bucket/data/file.txt\")\n\n# Match patterns\nprint(path.match(\"*.txt\"))           # True\nprint(path.match(\"**/data/*.txt\"))   # True\nprint(path.match(\"*.csv\"))           # False\n</code></pre>"},{"location":"guide/path-operations/#see-also","title":"See Also","text":"<ul> <li>API Reference - Complete API documentation</li> <li>Quick Start - Basic usage</li> </ul>"},{"location":"migration/from-cloudpathlib/","title":"Migration from cloudpathlib","text":"<p>This guide helps you migrate from cloudpathlib to PanPath.</p>"},{"location":"migration/from-cloudpathlib/#why-migrate","title":"Why Migrate?","text":"<p>PanPath offers several advantages over cloudpathlib:</p> <ul> <li>\u2705 Local path support - Same API for local and cloud storage</li> <li>\u2705 Explicit async/sync - Clear separation with better type safety</li> <li>\u2705 Better performance - Lazy client loading and optimized operations</li> <li>\u2705 Cross-storage operations - Copy/move between different providers</li> <li>\u2705 Simpler API - Unified <code>PanPath</code> instead of separate classes</li> </ul>"},{"location":"migration/from-cloudpathlib/#compatibility","title":"Compatibility","text":"<p>PanPath maintains compatibility with most cloudpathlib features. See Cloudpathlib Compatibility for detailed comparison.</p>"},{"location":"migration/from-cloudpathlib/#quick-migration-guide","title":"Quick Migration Guide","text":""},{"location":"migration/from-cloudpathlib/#installation","title":"Installation","text":"<p>cloudpathlib: <pre><code>pip install cloudpathlib[all]\n</code></pre></p> <p>PanPath: <pre><code>pip install panpath[all]\n</code></pre></p>"},{"location":"migration/from-cloudpathlib/#basic-path-creation","title":"Basic Path Creation","text":"cloudpathlibPanPath <pre><code>from cloudpathlib import CloudPath, S3Path, GSPath, AzureBlobPath\n\n# Generic (auto-dispatch)\npath = CloudPath(\"s3://bucket/key\")\n\n# Specific backends\ns3 = S3Path(\"s3://bucket/key\")\ngs = GSPath(\"gs://bucket/path\")\naz = AzureBlobPath(\"az://container/blob\")\n</code></pre> <pre><code>from panpath import PanPath\n\n# Generic (auto-dispatch)\npath = PanPath(\"s3://bucket/key\")\n\n# All backends use PanPath\ns3 = PanPath(\"s3://bucket/key\")\ngs = PanPath(\"gs://bucket/path\")\naz = PanPath(\"az://container/blob\")\n</code></pre>"},{"location":"migration/from-cloudpathlib/#reading-and-writing","title":"Reading and Writing","text":"<p>The API is identical:</p> cloudpathlibPanPath <pre><code>path = CloudPath(\"s3://bucket/file.txt\")\n\n# Read\ntext = path.read_text()\ndata = path.read_bytes()\n\n# Write\npath.write_text(\"content\")\npath.write_bytes(b\"data\")\n</code></pre> <pre><code>path = PanPath(\"s3://bucket/file.txt\")\n\n# Read (identical)\ntext = path.read_text()\ndata = path.read_bytes()\n\n# Write (identical)\npath.write_text(\"content\")\npath.write_bytes(b\"data\")\n</code></pre>"},{"location":"migration/from-cloudpathlib/#path-operations","title":"Path Operations","text":"<p>Most operations are identical:</p> cloudpathlibPanPath <pre><code>path = CloudPath(\"s3://bucket/dir/file.txt\")\n\n# Properties\nprint(path.name)        # file.txt\nprint(path.stem)        # file\nprint(path.suffix)      # .txt\nprint(path.parent)      # s3://bucket/dir\n\n# Joining\nnew = path.parent / \"other.txt\"\n\n# Modification\nrenamed = path.with_name(\"new.txt\")\n</code></pre> <pre><code>path = PanPath(\"s3://bucket/dir/file.txt\")\n\n# Properties (identical)\nprint(path.name)        # file.txt\nprint(path.stem)        # file\nprint(path.suffix)      # .txt\nprint(path.parent)      # s3://bucket/dir\n\n# Joining (identical)\nnew = path.parent / \"other.txt\"\n\n# Modification (identical)\nrenamed = path.with_name(\"new.txt\")\n</code></pre>"},{"location":"migration/from-cloudpathlib/#directory-operations","title":"Directory Operations","text":"cloudpathlibPanPath <pre><code>directory = CloudPath(\"s3://bucket/data/\")\n\n# Iterate\nfor item in directory.iterdir():\n    print(item)\n\n# Glob\ntxt_files = directory.glob(\"*.txt\")\npy_files = directory.rglob(\"*.py\")\n</code></pre> <pre><code>directory = PanPath(\"s3://bucket/data/\")\n\n# Iterate (identical)\nfor item in directory.iterdir():\n    print(item)\n\n# Glob (identical)\ntxt_files = directory.glob(\"*.txt\")\npy_files = directory.rglob(\"*.py\")\n</code></pre>"},{"location":"migration/from-cloudpathlib/#key-differences","title":"Key Differences","text":""},{"location":"migration/from-cloudpathlib/#1-async-support","title":"1. Async Support","text":"<p>cloudpathlib has async support mixed into the same classes.</p> <p>PanPath has explicit sync/async separation:</p> cloudpathlibPanPath <pre><code>from cloudpathlib import CloudPath\n\n# Sync (default)\npath = CloudPath(\"s3://bucket/file.txt\")\ncontent = path.read_text()\n\n# Async (not well-documented)\n# Limited async support\n</code></pre> <pre><code>from panpath import PanPath, AsyncPanPath\n\n# Sync (explicit)\npath = PanPath(\"s3://bucket/file.txt\")\ncontent = path.read_text()\n\n# Async (explicit)\nasync_path = PanPath(\"s3://bucket/file.txt\", mode=\"async\")\n# or\nasync_path = AsyncPanPath(\"s3://bucket/file.txt\")\ncontent = await async_path.read_text()\n</code></pre>"},{"location":"migration/from-cloudpathlib/#2-local-paths","title":"2. Local Paths","text":"<p>cloudpathlib doesn't support local paths.</p> <p>PanPath treats local paths the same as cloud paths:</p> cloudpathlibPanPath <pre><code>from cloudpathlib import CloudPath\nfrom pathlib import Path\n\n# Need different classes\ncloud_path = CloudPath(\"s3://bucket/file.txt\")\nlocal_path = Path(\"/tmp/file.txt\")\n\n# Different APIs\ncloud_content = cloud_path.read_text()\nlocal_content = local_path.read_text()\n</code></pre> <pre><code>from panpath import PanPath\n\n# Same class for everything\ncloud_path = PanPath(\"s3://bucket/file.txt\")\nlocal_path = PanPath(\"/tmp/file.txt\")\n\n# Same API\ncloud_content = cloud_path.read_text()\nlocal_content = local_path.read_text()\n</code></pre>"},{"location":"migration/from-cloudpathlib/#3-client-configuration","title":"3. Client Configuration","text":"<p>cloudpathlib uses client objects.</p> <p>PanPath uses lazy client creation with registry:</p> cloudpathlibPanPath <pre><code>from cloudpathlib import S3Client, S3Path\n\n# Create client\nclient = S3Client(\n    aws_access_key_id=\"key\",\n    aws_secret_access_key=\"secret\"\n)\n\n# Use with path\npath = S3Path(\"s3://bucket/file.txt\", client=client)\n</code></pre> <pre><code>from panpath import PanPath\nfrom panpath.clients import get_s3_client\n\n# Configure client (optional - uses env vars by default)\nclient = get_s3_client(\n    aws_access_key_id=\"key\",\n    aws_secret_access_key=\"secret\"\n)\n\n# Paths automatically use configured client\npath = PanPath(\"s3://bucket/file.txt\")\n</code></pre>"},{"location":"migration/from-cloudpathlib/#4-file-caching","title":"4. File Caching","text":"<p>cloudpathlib has built-in file caching.</p> <p>PanPath doesn't implement caching (yet):</p> cloudpathlibPanPath <pre><code>from cloudpathlib import S3Path\n\n# With caching\npath = S3Path(\"s3://bucket/file.txt\")\npath.fspath  # Downloads to cache\n</code></pre> <pre><code>from panpath import PanPath\n\n# No automatic caching\n# Manually download if needed\npath = PanPath(\"s3://bucket/file.txt\")\nlocal_copy = PanPath(\"/tmp/file.txt\")\npath.copy(local_copy)\n</code></pre>"},{"location":"migration/from-cloudpathlib/#migration-steps","title":"Migration Steps","text":""},{"location":"migration/from-cloudpathlib/#step-1-update-imports","title":"Step 1: Update Imports","text":"<p>Replace cloudpathlib imports:</p> <pre><code># Before\nfrom cloudpathlib import CloudPath, S3Path, GSPath\n\n# After\nfrom panpath import PanPath\n</code></pre>"},{"location":"migration/from-cloudpathlib/#step-2-update-path-creation","title":"Step 2: Update Path Creation","text":"<p>Replace specific path classes with <code>PanPath</code>:</p> <pre><code># Before\ns3 = S3Path(\"s3://bucket/key\")\ngs = GSPath(\"gs://bucket/path\")\n\n# After\ns3 = PanPath(\"s3://bucket/key\")\ngs = PanPath(\"gs://bucket/path\")\n</code></pre>"},{"location":"migration/from-cloudpathlib/#step-3-update-client-configuration","title":"Step 3: Update Client Configuration","text":"<p>If you use custom clients:</p> <pre><code># Before\nfrom cloudpathlib import S3Client, S3Path\n\nclient = S3Client(...)\npath = S3Path(\"s3://bucket/key\", client=client)\n\n# After\nfrom panpath import PanPath\nfrom panpath.clients import get_s3_client\n\nget_s3_client(...)  # Configure once\npath = PanPath(\"s3://bucket/key\")  # Uses configured client\n</code></pre>"},{"location":"migration/from-cloudpathlib/#step-4-update-async-code","title":"Step 4: Update Async Code","text":"<p>Make async operations explicit:</p> <pre><code># Before\nfrom cloudpathlib import CloudPath\n\npath = CloudPath(\"s3://bucket/file.txt\")\n# Might be async internally?\n\n# After\nfrom panpath import AsyncPanPath\n\nasync_path = AsyncPanPath(\"s3://bucket/file.txt\")\ncontent = await async_path.read_text()\n</code></pre>"},{"location":"migration/from-cloudpathlib/#step-5-remove-caching-code","title":"Step 5: Remove Caching Code","text":"<p>If you relied on automatic caching:</p> <pre><code># Before\nfrom cloudpathlib import S3Path\n\npath = S3Path(\"s3://bucket/file.txt\")\nlocal_path = path.fspath  # Cached local copy\n\n# After\nfrom panpath import PanPath\n\npath = PanPath(\"s3://bucket/file.txt\")\n# Download explicitly if needed\nlocal_path = \"/tmp/file.txt\"\npath.copy(local_path)\n</code></pre>"},{"location":"migration/from-cloudpathlib/#complete-example","title":"Complete Example","text":"<p>Here's a complete migration example:</p> cloudpathlibPanPath <pre><code>from cloudpathlib import CloudPath, S3Client\n\n# Configure client\nclient = S3Client(\n    aws_access_key_id=\"key\",\n    aws_secret_access_key=\"secret\"\n)\n\n# Process files\ndef process_files(bucket_uri: str):\n    directory = CloudPath(bucket_uri, client=client)\n\n    for txt_file in directory.glob(\"*.txt\"):\n        content = txt_file.read_text()\n\n        # Process content\n        processed = content.upper()\n\n        # Write to new location\n        output = txt_file.with_stem(f\"{txt_file.stem}_processed\")\n        output.write_text(processed)\n\nprocess_files(\"s3://my-bucket/data/\")\n</code></pre> <pre><code>from panpath import PanPath\nfrom panpath.clients import get_s3_client\n\n# Configure client (optional - uses env vars by default)\nget_s3_client(\n    aws_access_key_id=\"key\",\n    aws_secret_access_key=\"secret\"\n)\n\n# Process files\ndef process_files(bucket_uri: str):\n    directory = PanPath(bucket_uri)\n\n    for txt_file in directory.glob(\"*.txt\"):\n        content = txt_file.read_text()\n\n        # Process content\n        processed = content.upper()\n\n        # Write to new location\n        output = txt_file.with_stem(f\"{txt_file.stem}_processed\")\n        output.write_text(processed)\n\nprocess_files(\"s3://my-bucket/data/\")\n</code></pre>"},{"location":"migration/from-cloudpathlib/#testing","title":"Testing","text":""},{"location":"migration/from-cloudpathlib/#mocking","title":"Mocking","text":"<p>PanPath uses a different mocking strategy:</p> cloudpathlibPanPath <pre><code>import pytest\nfrom cloudpathlib import S3Path\nfrom cloudpathlib.local import LocalS3Path\n\ndef test_with_mock():\n    # Use local implementation\n    path = LocalS3Path(\"s3://bucket/file.txt\")\n    path.write_text(\"test\")\n    assert path.read_text() == \"test\"\n</code></pre> <pre><code>import pytest\nfrom panpath import PanPath\n\ndef test_with_mock():\n    # Use local paths for testing\n    path = PanPath(\"/tmp/test-bucket/file.txt\")\n    path.parent.mkdir(parents=True, exist_ok=True)\n    path.write_text(\"test\")\n    assert path.read_text() == \"test\"\n</code></pre>"},{"location":"migration/from-cloudpathlib/#compatibility-layer","title":"Compatibility Layer","text":"<p>If you need to maintain compatibility with both libraries:</p> <pre><code>def get_cloud_path(uri: str):\n    \"\"\"Get cloud path using available library.\"\"\"\n    try:\n        from panpath import PanPath\n        return PanPath(uri)\n    except ImportError:\n        from cloudpathlib import CloudPath\n        return CloudPath(uri)\n\n# Use it\npath = get_cloud_path(\"s3://bucket/file.txt\")\ncontent = path.read_text()\n</code></pre>"},{"location":"migration/from-cloudpathlib/#next-steps","title":"Next Steps","text":"<ul> <li>Quick Start - Learn PanPath basics</li> <li>User Guide - Detailed feature documentation</li> <li>API Reference - Complete API documentation</li> <li>Cloudpathlib Compatibility - Detailed compatibility info</li> </ul>"},{"location":"migration/from-pathlib/","title":"Migration from pathlib","text":"<p>This guide helps you migrate from Python's standard <code>pathlib</code> to PanPath.</p>"},{"location":"migration/from-pathlib/#why-migrate","title":"Why Migrate?","text":"<p>PanPath extends pathlib's interface to support cloud storage while maintaining full compatibility for local paths.</p>"},{"location":"migration/from-pathlib/#quick-migration","title":"Quick Migration","text":"<p>For local paths, PanPath is a drop-in replacement:</p> <pre><code># Before\nfrom pathlib import Path\n\npath = Path(\"/tmp/file.txt\")\ncontent = path.read_text()\n\n# After\nfrom panpath import PanPath\n\npath = PanPath(\"/tmp/file.txt\")\ncontent = path.read_text()\n</code></pre>"},{"location":"migration/from-pathlib/#extending-to-cloud","title":"Extending to Cloud","text":"<p>Once using PanPath, adding cloud support is trivial:</p> <pre><code>from panpath import PanPath\n\n# Same code works for cloud\npath = PanPath(\"s3://bucket/file.txt\")\ncontent = path.read_text()\n</code></pre>"},{"location":"migration/from-pathlib/#type-hints","title":"Type Hints","text":"<pre><code>from pathlib import Path\nfrom panpath import PanPath\n\n# Accept both\ndef process(path: Path | PanPath):\n    # Convert to PanPath if needed\n    if isinstance(path, Path):\n        path = PanPath(str(path))\n\n    # Now works with cloud too\n    return path.read_text()\n</code></pre>"},{"location":"migration/from-pathlib/#see-also","title":"See Also","text":"<ul> <li>Quick Start - Learn PanPath basics</li> <li>API Reference - Complete API</li> </ul>"},{"location":"providers/azure/","title":"Azure Blob Storage","text":"<p>Comprehensive guide for using PanPath with Azure Blob Storage.</p>"},{"location":"providers/azure/#installation","title":"Installation","text":"<pre><code># Sync support\npip install panpath[azure]\n\n# Async support\npip install panpath[async-azure]\n</code></pre>"},{"location":"providers/azure/#authentication","title":"Authentication","text":"<pre><code>export AZURE_STORAGE_CONNECTION_STRING=your_connection_string\n# or\nexport AZURE_STORAGE_ACCOUNT_NAME=your_account\nexport AZURE_STORAGE_ACCOUNT_KEY=your_key\n</code></pre>"},{"location":"providers/azure/#basic-usage","title":"Basic Usage","text":"<pre><code>from panpath import PanPath\n\n# URI format: az://container-name/path\n# or: azure://container-name/path\npath = PanPath(\"az://my-container/file.txt\")\n\n# Read and write\npath.write_text(\"Hello, Azure!\")\ncontent = path.read_text()\n</code></pre>"},{"location":"providers/azure/#see-also","title":"See Also","text":"<ul> <li>Quick Start - Basic usage</li> <li>Cloud Storage Guide - Cloud features</li> </ul>"},{"location":"providers/gcs/","title":"Google Cloud Storage","text":"<p>Comprehensive guide for using PanPath with Google Cloud Storage.</p>"},{"location":"providers/gcs/#installation","title":"Installation","text":"<pre><code># Sync support\npip install panpath[gs]\n\n# Async support\npip install panpath[async-gs]\n</code></pre>"},{"location":"providers/gcs/#authentication","title":"Authentication","text":"<pre><code>export GOOGLE_APPLICATION_CREDENTIALS=/path/to/credentials.json\n</code></pre>"},{"location":"providers/gcs/#basic-usage","title":"Basic Usage","text":"<pre><code>from panpath import PanPath\n\n# URI format: gs://bucket-name/path\npath = PanPath(\"gs://my-bucket/file.txt\")\n\n# Read and write\npath.write_text(\"Hello, GCS!\")\ncontent = path.read_text()\n</code></pre>"},{"location":"providers/gcs/#see-also","title":"See Also","text":"<ul> <li>Quick Start - Basic usage</li> <li>Cloud Storage Guide - Cloud features</li> </ul>"},{"location":"providers/s3/","title":"Amazon S3","text":"<p>Comprehensive guide for using PanPath with Amazon S3.</p>"},{"location":"providers/s3/#prerequisites","title":"Prerequisites","text":""},{"location":"providers/s3/#installation","title":"Installation","text":"<pre><code># Sync support\npip install panpath[s3]\n\n# Async support\npip install panpath[async-s3]\n\n# Both\npip install panpath[s3,async-s3]\n</code></pre>"},{"location":"providers/s3/#aws-credentials","title":"AWS Credentials","text":"<p>Configure AWS credentials using one of these methods:</p> Environment VariablesAWS Config FileIAM Role <pre><code>export AWS_ACCESS_KEY_ID=your_access_key\nexport AWS_SECRET_ACCESS_KEY=your_secret_key\nexport AWS_DEFAULT_REGION=us-east-1\n</code></pre> <pre><code># ~/.aws/credentials\n[default]\naws_access_key_id = your_access_key\naws_secret_access_key = your_secret_key\n\n# ~/.aws/config\n[default]\nregion = us-east-1\n</code></pre> <pre><code># When running on EC2, ECS, or Lambda\n# Credentials are automatically obtained from IAM role\nfrom panpath import PanPath\n\npath = PanPath(\"s3://bucket/file.txt\")\n# Uses IAM role credentials automatically\n</code></pre>"},{"location":"providers/s3/#basic-usage","title":"Basic Usage","text":""},{"location":"providers/s3/#uri-format","title":"URI Format","text":"<pre><code>from panpath import PanPath\n\n# Format: s3://bucket-name/key/path\npath = PanPath(\"s3://my-bucket/data/file.txt\")\n\n# Bucket root\nbucket = PanPath(\"s3://my-bucket/\")\n\n# Nested paths\nnested = PanPath(\"s3://my-bucket/folder/subfolder/file.txt\")\n</code></pre>"},{"location":"providers/s3/#reading-and-writing","title":"Reading and Writing","text":"Text FilesBinary FilesUsing open() <pre><code>from panpath import PanPath\n\npath = PanPath(\"s3://my-bucket/data.txt\")\n\n# Write text\npath.write_text(\"Hello, S3!\")\n\n# Read text\ncontent = path.read_text()\nprint(content)  # Hello, S3!\n\n# With encoding\npath.write_text(\"Hello\", encoding=\"utf-8\")\ncontent = path.read_text(encoding=\"utf-8\")\n</code></pre> <pre><code>from panpath import PanPath\n\npath = PanPath(\"s3://my-bucket/data.bin\")\n\n# Write bytes\npath.write_bytes(b\"\\x00\\x01\\x02\\x03\")\n\n# Read bytes\ndata = path.read_bytes()\n</code></pre> <pre><code>from panpath import PanPath\n\npath = PanPath(\"s3://my-bucket/log.txt\")\n\n# Write\nwith path.open(\"w\") as f:\n    f.write(\"Line 1\\n\")\n    f.write(\"Line 2\\n\")\n\n# Read\nwith path.open(\"r\") as f:\n    for line in f:\n        print(line.strip())\n</code></pre>"},{"location":"providers/s3/#path-operations","title":"Path Operations","text":"<pre><code>from panpath import PanPath\n\npath = PanPath(\"s3://my-bucket/data/file.txt\")\n\n# Path components\nprint(path.name)        # file.txt\nprint(path.stem)        # file\nprint(path.suffix)      # .txt\nprint(path.parent)      # s3://my-bucket/data\n\n# Join paths\nnew_path = path.parent / \"other.txt\"\nprint(new_path)  # s3://my-bucket/data/other.txt\n\n# Modify components\nrenamed = path.with_name(\"newfile.txt\")\nprint(renamed)  # s3://my-bucket/data/newfile.txt\n\ndifferent_ext = path.with_suffix(\".csv\")\nprint(different_ext)  # s3://my-bucket/data/file.csv\n</code></pre>"},{"location":"providers/s3/#directory-operations","title":"Directory Operations","text":""},{"location":"providers/s3/#listing-objects","title":"Listing Objects","text":"<pre><code>from panpath import PanPath\n\nbucket = PanPath(\"s3://my-bucket/data/\")\n\n# List all items\nfor item in bucket.iterdir():\n    print(item)\n\n# Find specific files\nfor txt_file in bucket.glob(\"*.txt\"):\n    print(txt_file)\n\n# Recursive search\nfor py_file in bucket.rglob(\"*.py\"):\n    print(py_file)\n</code></pre>"},{"location":"providers/s3/#walking-directory-tree","title":"Walking Directory Tree","text":"<pre><code>from panpath import PanPath\n\nbucket = PanPath(\"s3://my-bucket/\")\n\nfor dirpath, dirnames, filenames in bucket.walk():\n    print(f\"Directory: {dirpath}\")\n    print(f\"  Subdirectories: {dirnames}\")\n    print(f\"  Files: {filenames}\")\n</code></pre>"},{"location":"providers/s3/#creating-directories","title":"Creating Directories","text":"<pre><code>from panpath import PanPath\n\n# Create directory (creates marker object)\ndirectory = PanPath(\"s3://my-bucket/new-folder/\")\ndirectory.mkdir(parents=True, exist_ok=True)\n</code></pre>"},{"location":"providers/s3/#async-operations","title":"Async Operations","text":""},{"location":"providers/s3/#basic-async-usage","title":"Basic Async Usage","text":"<pre><code>import asyncio\nfrom panpath import AsyncPanPath\n\nasync def main():\n    path = AsyncPanPath(\"s3://my-bucket/file.txt\")\n\n    # Write\n    await path.write_text(\"Async content\")\n\n    # Read\n    content = await path.read_text()\n    print(content)\n\nasyncio.run(main())\n</code></pre>"},{"location":"providers/s3/#async-context-manager","title":"Async Context Manager","text":"<pre><code>import asyncio\nfrom panpath import AsyncPanPath\n\nasync def main():\n    path = AsyncPanPath(\"s3://my-bucket/log.txt\")\n\n    # Write\n    async with path.open(\"w\") as f:\n        await f.write(\"Line 1\\n\")\n        await f.write(\"Line 2\\n\")\n\n    # Read\n    async with path.open(\"r\") as f:\n        content = await f.read()\n        print(content)\n\nasyncio.run(main())\n</code></pre>"},{"location":"providers/s3/#parallel-operations","title":"Parallel Operations","text":"<pre><code>import asyncio\nfrom panpath import AsyncPanPath\n\nasync def download_all(uris: list[str]):\n    \"\"\"Download multiple files concurrently.\"\"\"\n    paths = [AsyncPanPath(uri) for uri in uris]\n    contents = await asyncio.gather(*[p.read_text() for p in paths])\n    return contents\n\nuris = [\n    \"s3://my-bucket/file1.txt\",\n    \"s3://my-bucket/file2.txt\",\n    \"s3://my-bucket/file3.txt\",\n]\n\nasyncio.run(download_all(uris))\n</code></pre>"},{"location":"providers/s3/#advanced-features","title":"Advanced Features","text":""},{"location":"providers/s3/#server-side-copy","title":"Server-Side Copy","text":"<p>S3 supports server-side copy for efficient copying within S3:</p> <pre><code>from panpath import PanPath\n\n# Fast: No download/upload\nsrc = PanPath(\"s3://my-bucket/source.txt\")\nsrc.copy(\"s3://my-bucket/backup/source.txt\")\n\n# Also works across buckets\nsrc.copy(\"s3://other-bucket/source.txt\")\n</code></pre>"},{"location":"providers/s3/#multipart-upload","title":"Multipart Upload","text":"<p>Large files are automatically handled with multipart upload:</p> <pre><code>from panpath import PanPath\n\n# Large file (&gt;5GB)\nlarge_file = PanPath(\"s3://my-bucket/large-file.bin\")\n\n# Automatically uses multipart upload\nwith open(\"/local/large-file.bin\", \"rb\") as f:\n    large_file.write_bytes(f.read())\n</code></pre>"},{"location":"providers/s3/#object-metadata","title":"Object Metadata","text":"<pre><code>from panpath import PanPath\n\npath = PanPath(\"s3://my-bucket/file.txt\")\n\n# Get metadata via stat()\nstat = path.stat()\nprint(f\"Size: {stat.st_size} bytes\")\nprint(f\"Modified: {stat.st_mtime}\")\n</code></pre>"},{"location":"providers/s3/#s3-specific-properties","title":"S3-Specific Properties","text":"<pre><code>from panpath import PanPath\n\npath = PanPath(\"s3://my-bucket/folder/file.txt\")\n\n# Cloud prefix (bucket)\nprint(path.cloud_prefix)  # s3://my-bucket\n\n# Key (path within bucket)\nprint(path.key)  # folder/file.txt\n\n# Bucket name\nprint(path.bucket)  # my-bucket\n</code></pre>"},{"location":"providers/s3/#performance-tips","title":"Performance Tips","text":""},{"location":"providers/s3/#1-use-async-for-multiple-operations","title":"1. Use Async for Multiple Operations","text":"<pre><code># Slow: Sequential\nfrom panpath import PanPath\n\nfor i in range(100):\n    path = PanPath(f\"s3://bucket/file{i}.txt\")\n    content = path.read_text()\n\n# Fast: Concurrent\nfrom panpath import AsyncPanPath\nimport asyncio\n\nasync def read_all():\n    paths = [AsyncPanPath(f\"s3://bucket/file{i}.txt\") for i in range(100)]\n    contents = await asyncio.gather(*[p.read_text() for p in paths])\n    return contents\n\nasyncio.run(read_all())\n</code></pre>"},{"location":"providers/s3/#2-use-server-side-copy","title":"2. Use Server-Side Copy","text":"<pre><code># Slow: Downloads then uploads\nsrc = PanPath(\"s3://bucket/large.bin\")\ncontent = src.read_bytes()\ndst = PanPath(\"s3://bucket/backup/large.bin\")\ndst.write_bytes(content)\n\n# Fast: Server-side copy\nsrc.copy(\"s3://bucket/backup/large.bin\")\n</code></pre>"},{"location":"providers/s3/#3-batch-operations","title":"3. Batch Operations","text":"<pre><code>from panpath import PanPath\n\n# Copy entire directory efficiently\nsrc_dir = PanPath(\"s3://bucket/data/\")\nsrc_dir.copytree(\"s3://bucket/backup/\")\n</code></pre>"},{"location":"providers/s3/#configuration","title":"Configuration","text":""},{"location":"providers/s3/#custom-client","title":"Custom Client","text":"<pre><code>from panpath import PanPath\nfrom panpath.clients import get_s3_client\n\n# Configure with custom settings\nclient = get_s3_client(\n    aws_access_key_id=\"your_key\",\n    aws_secret_access_key=\"your_secret\",\n    region_name=\"us-west-2\",\n    endpoint_url=\"https://custom-s3-endpoint.com\"  # For S3-compatible services\n)\n\n# Paths will use this configuration\npath = PanPath(\"s3://bucket/file.txt\")\n</code></pre>"},{"location":"providers/s3/#s3-compatible-services","title":"S3-Compatible Services","text":"<p>PanPath works with S3-compatible services (MinIO, DigitalOcean Spaces, etc.):</p> <pre><code>from panpath.clients import get_s3_client\n\n# Configure for MinIO\nget_s3_client(\n    endpoint_url=\"http://localhost:9000\",\n    aws_access_key_id=\"minioadmin\",\n    aws_secret_access_key=\"minioadmin\"\n)\n\n# Use normally\nfrom panpath import PanPath\npath = PanPath(\"s3://my-bucket/file.txt\")\n</code></pre>"},{"location":"providers/s3/#error-handling","title":"Error Handling","text":"<pre><code>from panpath import PanPath\nfrom panpath.exceptions import (\n    PathNotFoundError,\n    PermissionError,\n)\nimport botocore.exceptions\n\npath = PanPath(\"s3://bucket/file.txt\")\n\ntry:\n    content = path.read_text()\nexcept PathNotFoundError:\n    print(\"File not found\")\nexcept PermissionError:\n    print(\"Access denied\")\nexcept botocore.exceptions.NoCredentialsError:\n    print(\"AWS credentials not configured\")\nexcept botocore.exceptions.ClientError as e:\n    error_code = e.response['Error']['Code']\n    if error_code == '404':\n        print(\"File not found\")\n    elif error_code == '403':\n        print(\"Access denied\")\n</code></pre>"},{"location":"providers/s3/#examples","title":"Examples","text":""},{"location":"providers/s3/#process-csv-files","title":"Process CSV Files","text":"<pre><code>from panpath import PanPath\nimport csv\nfrom io import StringIO\n\ndef process_csv(s3_uri: str):\n    path = PanPath(s3_uri)\n\n    # Read CSV\n    content = path.read_text()\n    reader = csv.DictReader(StringIO(content))\n\n    # Process rows\n    for row in reader:\n        print(row)\n\nprocess_csv(\"s3://my-bucket/data.csv\")\n</code></pre>"},{"location":"providers/s3/#backup-to-s3","title":"Backup to S3","text":"<pre><code>from panpath import PanPath\nfrom datetime import datetime\n\ndef backup_to_s3(local_dir: str, s3_bucket: str):\n    timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n\n    src = PanPath(local_dir)\n    dst = PanPath(f\"s3://{s3_bucket}/backup_{timestamp}/\")\n\n    print(f\"Backing up {src} to {dst}...\")\n    src.copytree(dst)\n    print(\"Backup complete!\")\n\nbackup_to_s3(\"/important/data/\", \"my-backups\")\n</code></pre>"},{"location":"providers/s3/#download-dataset","title":"Download Dataset","text":"<pre><code>from panpath import PanPath\n\ndef download_dataset(s3_uri: str, local_dir: str):\n    src = PanPath(s3_uri)\n    dst = PanPath(local_dir)\n\n    print(f\"Downloading {src}...\")\n    src.copytree(dst)\n    print(f\"Downloaded to {dst}\")\n\ndownload_dataset(\"s3://datasets/imagenet/\", \"/data/imagenet/\")\n</code></pre>"},{"location":"providers/s3/#see-also","title":"See Also","text":"<ul> <li>Quick Start - Basic usage</li> <li>Async Operations - Async patterns</li> <li>Bulk Operations - Efficient file operations</li> <li>API Reference - Complete S3 API</li> </ul>"}]}